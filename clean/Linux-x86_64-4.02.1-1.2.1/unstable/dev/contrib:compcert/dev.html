<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Coq bench</title>
    <link rel="shortcut icon" type="image/png" href="../../../../../favicon.png" />
    <link href="../../../../../bootstrap.min.css" rel="stylesheet">
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <script src="../../../../../moment.min.js"></script>
    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container">
      <div class="navbar navbar-default" role="navigation">
        <div class="container-fluid">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="../../../../.."><i class="fa fa-lg fa-flag-checkered"></i> Coq bench</a>
          </div>
          <div id="navbar" class="collapse navbar-collapse">
            <ul class="nav navbar-nav">
              <li><a href="../..">clean / unstable</a></li>
              <li class="active"><a href="">dev / contrib:compcert - dev</a></li>
            </ul>
          </div>
        </div>
      </div>
      <div class="article">
        <div class="row">
          <div class="col-md-12">
            <a href="../..">Â« Up</a>
            <h1>
              contrib:compcert
              <small>
                dev
                <span class="label label-danger">Error</span>
              </small>
            </h1>
            <p><em><script>document.write(moment("2015-04-19 06:10:19 +0000", "YYYY-MM-DD HH:mm:ss Z").fromNow());</script> (2015-04-19 06:10:19 UTC)</em><p>
            <h2>Context</h2>
            <pre># Installed packages for system:
base-bigarray  base  Bigarray library distributed with the OCaml compiler
base-threads   base  Threads library distributed with the OCaml compiler
base-unix      base  Unix library distributed with the OCaml compiler
camlp5         6.12  Preprocessor-pretty-printer of OCaml
coq             dev  Formal proof management system.
</pre>
            <h2>Lint</h2>
            <dl class="dl-horizontal">
              <dt>Command</dt>
              <dd><code>ruby lint.rb unstable ../unstable/packages/coq:contrib:compcert/coq:contrib:compcert.dev</code></dd>
              <dt>Return code</dt>
              <dd>0</dd>
            </dl>
            <h2>Dry install</h2>
            <p>Dry install with the current Coq version:</p>
            <dl class="dl-horizontal">
              <dt>Command</dt>
              <dd><code>opam install -y --show-action coq:contrib:compcert.dev coq.dev</code></dd>
              <dt>Return code</dt>
              <dd>0</dd>
            </dl>
            <p>Dry install without Coq, to test if the problem was incompatibility with the current Coq version:</p>
            <dl class="dl-horizontal">
              <dt>Command</dt>
              <dd><code>true</code></dd>
              <dt>Return code</dt>
              <dd>0</dd>
            </dl>
            <h2>Install dependencies</h2>
            <dl class="dl-horizontal">
              <dt>Command</dt>
              <dd><code>opam list; ulimit -Sv 1000000; timeout 5m opam install -y --deps-only coq:contrib:compcert.dev</code></dd>
              <dt>Return code</dt>
              <dd>0</dd>
              <dt>Duration</dt>
              <dd>2 s</dd>
            </dl>
            <h2>Install</h2>
            <dl class="dl-horizontal">
              <dt>Command</dt>
              <dd><code>opam list; ulimit -Sv 4000000; timeout 120m opam install -y -v coq:contrib:compcert.dev</code></dd>
              <dt>Return code</dt>
              <dd>1024</dd>
              <dt>Duration</dt>
              <dd>6 m 42 s</dd>
              <dt>Output</dt>
              <dd><pre># Installed packages for system:
base-bigarray  base  Bigarray library distributed with the OCaml compiler
base-threads   base  Threads library distributed with the OCaml compiler
base-unix      base  Unix library distributed with the OCaml compiler
camlp5         6.12  Preprocessor-pretty-printer of OCaml
coq             dev  Formal proof management system.
The following actions will be performed:
  - install coq:contrib:compcert dev
=-=- Gathering sources =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
[coq:contrib:compcert: from unstable] Repo archive not found[coq:contrib:compcert: git] Command started
[coq:contrib:compcert: git] Command started
[coq:contrib:compcert: git] Command started
[coq:contrib:compcert: git] Command started
[coq:contrib:compcert: git] Command started
[coq:contrib:compcert: git] Command started
[coq:contrib:compcert] https://gforge.inria.fr/git/coq-contribs/compcert.git#trunk updated
=-=- Processing actions -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
[coq:contrib:compcert: ./configure ia32-linux] Command started
+ ./configure &quot;ia32-linux&quot; (CWD=/home/bench/.opam/system/build/coq:contrib:compcert.dev)
- Testing assembler support for CFI directives... yes
- 
- CompCert configuration:
-     Target architecture........... ia32
-     Application binary interface.. standard
-     OS and development env........ linux
-     C compiler.................... gcc -m32
-     C preprocessor................ gcc -m32 -U__GNUC__ -E
-     Assembler..................... gcc -m32 -c
-     Assembler supports CFI........ true
-     Assembler for runtime lib..... gcc -m32 -c
-     Linker........................ gcc -m32
-     Math library.................. -lm
-     Binaries installed in......... /usr/local/bin
-     Runtime library provided...... true
-     Library files installed in.... /usr/local/lib/compcert
-     cchecklink tool supported..... false
- 
- If anything above looks wrong, please edit file ./Makefile.config to correct.
- 
[coq:contrib:compcert: make] Command started
+ make &quot;-j4&quot; (CWD=/home/bench/.opam/system/build/coq:contrib:compcert.dev)
- make proof
- make[1]: Entering directory &#39;/home/bench/.opam/system/build/coq:contrib:compcert.dev&#39;
- COQC lib/Axioms.v
- COQC lib/Coqlib.v
- ocamlopt -o tools/ndfun str.cmxa tools/ndfun.ml
- COQC flocq/Core/Fcore_Zaux.v
- COQC driver/Compopts.v
- COQC lib/Wfsimpl.v
- Preprocessing ia32/SelectOp.vp
- Preprocessing backend/SelectDiv.vp
- Preprocessing backend/SelectLong.vp
- Preprocessing ia32/ConstpropOp.vp
- File &quot;tools/ndfun.ml&quot;, line 12, characters 10-23:
- Warning 3: deprecated: String.create
- Use Bytes.create instead.
- File &quot;tools/ndfun.ml&quot;, line 14, characters 4-52:
- Warning 3: deprecated: String.set
- Use Bytes.set instead.
- COQC flocq/Core/Fcore_Raux.v
- COQC flocq/Core/Fcore_digits.v
- COQC lib/Intv.v
- COQC lib/Maps.v
- COQC lib/Integers.v
- princ_type := forall P : Z -&gt; list Z -&gt; Type,
-               (forall (hi : Z) (_x : lo &lt; hi),
-                zlt lo hi = left _x -&gt;
-                P (hi - 1) (elements_rec (hi - 1)) -&gt;
-                P hi (hi - 1 :: elements_rec (hi - 1))) -&gt;
-               (forall (hi : Z) (_x : lo &gt;= hi),
-                zlt lo hi = right _x -&gt; P hi nil) -&gt;
-               forall hi : Z, P hi (elements_rec hi)
- TITI R_elements_rec_0 y y0 y1 (elements_rec (y - 1))
-        (y2 (elements_rec (y - 1)) eq_refl)
- TITI R_elements_rec_1 y y0 y1
- COQC lib/Iteration.v
- princ_type := forall P : Z -&gt; A -&gt; Type,
-               (forall (hi : Z) (_x : lo &lt; hi),
-                zlt lo hi = left _x -&gt;
-                P (hi - 1) (fold_rec (hi - 1)) -&gt;
-                P hi (f (hi - 1) (fold_rec (hi - 1)))) -&gt;
-               (forall (hi : Z) (_x : lo &gt;= hi),
-                zlt lo hi = right _x -&gt; P hi a) -&gt;
-               forall hi : Z, P hi (fold_rec hi)
- TITI R_fold_rec_0 y y0 y1 (fold_rec (y - 1)) (y2 (fold_rec (y - 1)) eq_refl)
- TITI R_fold_rec_1 y y0 y1
- COQC flocq/Core/Fcore_defs.v
- COQC lib/Parmov.v
- COQC lib/UnionFind.v
- COQC lib/FSetAVLplus.v
- COQC lib/IntvSets.v
- COQC common/Errors.v
- princ_type := forall P : moves -&gt; reg -&gt; option (moves * reg * moves) -&gt; Type,
-               (forall (m : moves) (r : reg), m = nil -&gt; P nil r None) -&gt;
-               (forall (m : moves) (r s d : reg) (tl : list (reg * reg)),
-                m = (s, d) :: tl -&gt;
-                forall _x : s = r,
-                reg_eq s r = left _x -&gt; P ((s, d) :: tl) r (Some (nil, d, tl))) -&gt;
-               (forall (m : moves) (r s d : reg) (tl : list (reg * reg)),
-                m = (s, d) :: tl -&gt;
-                forall _x : s &lt;&gt; r,
-                reg_eq s r = right _x -&gt;
-                P tl r (split_move tl r) -&gt;
-                split_move tl r = None -&gt; P ((s, d) :: tl) r None) -&gt;
-               (forall (m : moves) (r s d : reg) (tl : list (reg * reg)),
-                m = (s, d) :: tl -&gt;
-                forall _x : s &lt;&gt; r,
-                reg_eq s r = right _x -&gt;
-                P tl r (split_move tl r) -&gt;
-                forall (before : moves) (d&#39; : reg) (after : moves),
-                split_move tl r = Some (before, d&#39;, after) -&gt;
-                P ((s, d) :: tl) r (Some ((s, d) :: before, d&#39;, after))) -&gt;
-               forall (m : moves) (r : reg), P m r (split_move m r)
- TITI R_split_move_0 y y0 y1
- TITI R_split_move_1 y y0 y1 y2 y3 y4 y5 y6
- TITI R_split_move_2 y y0 y1 y2 y3 y4 y5 y6 (split_move y3 y0)
-        (y7 (split_move y3 y0) eq_refl) y8
- TITI R_split_move_3 y y0 y1 y2 y3 y4 y5 y6 (split_move y3 y0)
-        (y7 (split_move y3 y0) eq_refl) y8 y9 y10 y11
- princ_type := forall (r : reg) (P : moves -&gt; bool -&gt; Type),
-               (forall m : moves, m = nil -&gt; P nil false) -&gt;
-               (forall (m : moves) (s d : reg),
-                m = (s, d) :: nil -&gt;
-                forall _x : s = r,
-                reg_eq s r = left _x -&gt; P ((s, d) :: nil) true) -&gt;
-               (forall (m : moves) (s d : reg),
-                m = (s, d) :: nil -&gt;
-                forall _x : s &lt;&gt; r,
-                reg_eq s r = right _x -&gt; P ((s, d) :: nil) false) -&gt;
-               (forall (m : moves) (s d : reg) (tl : list (reg * reg)),
-                m = (s, d) :: tl -&gt;
-                match (s, d) :: tl with
-                | nil =&gt; False
-                | (_, _) :: nil =&gt; False
-                | (_, _) :: _ :: _ =&gt; True
-                end -&gt;
-                P tl (is_last_source r tl) -&gt;
-                P ((s, d) :: tl) (is_last_source r tl)) -&gt;
-               forall m : moves, P m (is_last_source r m)
- TITI R_is_last_source_0 x y y0
- TITI R_is_last_source_1 x y y0 y1 y2 y3 y4
- TITI R_is_last_source_2 x y y0 y1 y2 y3 y4
- TITI R_is_last_source_3 x y y0 y1 y2 y3 y4 (is_last_source x y2)
-        (y5 (is_last_source x y2) eq_refl)
- princ_type := forall (r : reg) (P : moves -&gt; moves -&gt; Type),
-               (forall m : moves, m = nil -&gt; P nil nil) -&gt;
-               (forall (m : moves) (s d : reg),
-                m = (s, d) :: nil -&gt; P ((s, d) :: nil) ((r, d) :: nil)) -&gt;
-               (forall (m : moves) (s_d : reg * reg) (tl : list (reg * reg)),
-                m = s_d :: tl -&gt;
-                match s_d :: tl with
-                | nil =&gt; False
-                | (_, _) :: nil =&gt; False
-                | (_, _) :: _ :: _ =&gt; True
-                end -&gt;
-                P tl (replace_last_source r tl) -&gt;
-                P (s_d :: tl) (s_d :: replace_last_source r tl)) -&gt;
-               forall m : moves, P m (replace_last_source r m)
- TITI R_replace_last_source_0 x y y0
- TITI R_replace_last_source_1 x y y0 y1 y2
- TITI R_replace_last_source_2 x y y0 y1 y2 y3 (replace_last_source x y1)
-        (y4 (replace_last_source x y1) eq_refl)
- COQC lib/Lattice.v
- princ_type := forall P : state -&gt; moves -&gt; Type,
-               (forall st : state,
-                final_state st = true -&gt;
-                forall _x _x0 tau : moves,
-                st = State _x _x0 tau -&gt; P (State _x _x0 tau) tau) -&gt;
-               (forall st : state,
-                final_state st = false -&gt;
-                P (parmove_step st) (parmove_aux (parmove_step st)) -&gt;
-                P st (parmove_aux (parmove_step st))) -&gt;
-               forall st : state, P st (parmove_aux st)
- TITI R_parmove_aux_0 y y0 y1 y2 y3 y4
- TITI R_parmove_aux_1 y y0 (parmove_aux (parmove_step y))
-        (y1 (parmove_aux (parmove_step y)) eq_refl)
- COQC flocq/Core/Fcore_float_prop.v
- COQC flocq/Core/Fcore_rnd.v
- COQC lib/Postorder.v
- COQC common/Subtyping.v
- COQC lib/Ordered.v
- COQC flocq/Calc/Fcalc_digits.v
- COQC flocq/Calc/Fcalc_bracket.v
- princ_type := forall P : typenv -&gt; res typenv -&gt; Type,
-               (forall e e&#39; : typenv,
-                solve_rec {| te_typ := te_typ e; te_sub := nil |} false
-                  (te_sub e) = OK (e&#39;, false) -&gt; P e (OK e)) -&gt;
-               (forall e e&#39; : typenv,
-                solve_rec {| te_typ := te_typ e; te_sub := nil |} false
-                  (te_sub e) = OK (e&#39;, true) -&gt;
-                P e&#39; (solve_constraints e&#39;) -&gt; P e (solve_constraints e&#39;)) -&gt;
-               (forall (e : typenv) (msg : errmsg),
-                solve_rec {| te_typ := te_typ e; te_sub := nil |} false
-                  (te_sub e) = Error msg -&gt; P e (Error msg)) -&gt;
-               forall e : typenv, P e (solve_constraints e)
- TITI R_solve_constraints_0 y y0 y1
- TITI R_solve_constraints_1 y y0 y1 (solve_constraints y0)
-        (y2 (solve_constraints y0) eq_refl)
- TITI R_solve_constraints_2 y y0 y1
- COQC flocq/Calc/Fcalc_ops.v
- COQC common/Switch.v
- COQC lib/Heaps.v
- COQC flocq/Core/Fcore_generic_fmt.v
- COQC flocq/Calc/Fcalc_div.v
- COQC flocq/Calc/Fcalc_sqrt.v
- COQC flocq/Core/Fcore_ulp.v
- COQC flocq/Prop/Fprop_Sterbenz.v
- COQC flocq/Prop/Fprop_plus_error.v
- COQC flocq/Core/Fcore_rnd_ne.v
- COQC flocq/Core/Fcore_FIX.v
- COQC flocq/Core/Fcore_FLX.v
- COQC flocq/Core/Fcore_FLT.v
- COQC flocq/Core/Fcore_FTZ.v
- COQC flocq/Core/Fcore.v
- COQC flocq/Calc/Fcalc_round.v
- COQC flocq/Prop/Fprop_mult_error.v
- COQC flocq/Prop/Fprop_relative.v
- COQC flocq/Appli/Fappli_rnd_odd.v
- COQC flocq/Prop/Fprop_div_sqrt_error.v
- COQC flocq/Appli/Fappli_IEEE.v
- COQC flocq/Appli/Fappli_IEEE_bits.v
- COQC ia32/Archi.v
- COQC lib/Floats.v
- COQC backend/Kildall.v
- COQC common/AST.v
- COQC common/Values.v
- COQC backend/Registers.v
- COQC cfrontend/Ctypes.v
- COQC common/Memdata.v
- COQC common/Memtype.v
- COQC common/Memory.v
- COQC common/Globalenvs.v
- COQC cfrontend/Cop.v
- princ_type := forall P : mem -&gt; block -&gt; Z -&gt; Z -&gt; option mem -&gt; Type,
-               (forall (m : mem) (b : block) (p n : Z) (_x : n &lt;= 0),
-                zle n 0 = left _x -&gt; P m b p n (Some m)) -&gt;
-               (forall (m : mem) (b : block) (p n : Z) (_x : n &gt; 0),
-                zle n 0 = right _x -&gt;
-                forall m&#39; : mem,
-                Mem.store Mint8unsigned m b p Vzero = Some m&#39; -&gt;
-                P m&#39; b (p + 1) (n - 1) (store_zeros m&#39; b (p + 1) (n - 1)) -&gt;
-                P m b p n (store_zeros m&#39; b (p + 1) (n - 1))) -&gt;
-               (forall (m : mem) (b : block) (p n : Z) (_x : n &gt; 0),
-                zle n 0 = right _x -&gt;
-                Mem.store Mint8unsigned m b p Vzero = None -&gt; P m b p n None) -&gt;
-               forall (m : mem) (b : block) (p n : Z),
-               P m b p n (store_zeros m b p n)
- TITI R_store_zeros_0 y y0 y1 y2 y3 y4
- TITI R_store_zeros_1 y y0 y1 y2 y3 y4 y5 y6
-        (store_zeros y5 y0 (y1 + 1) (y2 - 1))
-        (y7 (store_zeros y5 y0 (y1 + 1) (y2 - 1)) eq_refl)
- TITI R_store_zeros_2 y y0 y1 y2 y3 y4 y5
- COQC cfrontend/Csyntax.v
- COQC common/Events.v
- COQC cfrontend/Initializers.v
- COQC common/Smallstep.v
- COQC ia32/Op.v
- COQC common/Behaviors.v
- COQC cfrontend/Csem.v
- COQC backend/Cminor.v
- COQC cfrontend/Clight.v
- COQC common/Determinism.v
- COQC cfrontend/Cstrategy.v
- COQC cfrontend/Initializersproof.v
- COQC cfrontend/SimplExpr.v
- princ_type := forall P : expr -&gt; option val -&gt; Type,
-               (forall (a : expr) (n : int) (_x : type),
-                a = Econst_int n _x -&gt; P (Econst_int n _x) (Some (Vint n))) -&gt;
-               (forall (a : expr) (n : float) (_x : type),
-                a = Econst_float n _x -&gt;
-                P (Econst_float n _x) (Some (Vfloat n))) -&gt;
-               (forall (a : expr) (n : int64) (_x : type),
-                a = Econst_long n _x -&gt; P (Econst_long n _x) (Some (Vlong n))) -&gt;
-               (forall (a b : expr) (ty : type),
-                a = Ecast b ty -&gt;
-                P b (eval_simpl_expr b) -&gt;
-                eval_simpl_expr b = None -&gt; P (Ecast b ty) None) -&gt;
-               (forall (a b : expr) (ty : type),
-                a = Ecast b ty -&gt;
-                P b (eval_simpl_expr b) -&gt;
-                forall v : val,
-                eval_simpl_expr b = Some v -&gt;
-                P (Ecast b ty) (sem_cast v (typeof b) ty)) -&gt;
-               (forall a _x : expr,
-                a = _x -&gt;
-                match _x with
-                | Econst_int _ _ =&gt; False
-                | Econst_float _ _ =&gt; False
-                | Econst_long _ _ =&gt; False
-                | Evar _ _ =&gt; True
-                | Etempvar _ _ =&gt; True
-                | Ederef _ _ =&gt; True
-                | Eaddrof _ _ =&gt; True
-                | Eunop _ _ _ =&gt; True
-                | Ebinop _ _ _ _ =&gt; True
-                | Ecast _ _ =&gt; False
-                | Efield _ _ _ =&gt; True
-                end -&gt; P _x None) -&gt; forall a : expr, P a (eval_simpl_expr a)
- TITI R_eval_simpl_expr_0 y y0 y1 y2
- TITI R_eval_simpl_expr_1 y y0 y1 y2
- TITI R_eval_simpl_expr_2 y y0 y1 y2
- TITI R_eval_simpl_expr_3 y y0 y1 y2 (eval_simpl_expr y0)
-        (y3 (eval_simpl_expr y0) eq_refl) y4
- TITI R_eval_simpl_expr_4 y y0 y1 y2 (eval_simpl_expr y0)
-        (y3 (eval_simpl_expr y0) eq_refl) y4 y5
- TITI R_eval_simpl_expr_5 y y0 y1 y2
- princ_type := forall (a : expr) (s1 s2 : statement) (P : statement -&gt; Type),
-               (forall v : val,
-                eval_simpl_expr a = Some v -&gt;
-                forall b : bool,
-                bool_val v (typeof a) = Some b -&gt; b = true -&gt; P s1) -&gt;
-               (forall v : val,
-                eval_simpl_expr a = Some v -&gt;
-                forall b : bool,
-                bool_val v (typeof a) = Some b -&gt; b = false -&gt; P s2) -&gt;
-               (forall v : val,
-                eval_simpl_expr a = Some v -&gt;
-                bool_val v (typeof a) = None -&gt; P (Sifthenelse a s1 s2)) -&gt;
-               (eval_simpl_expr a = None -&gt; P (Sifthenelse a s1 s2)) -&gt;
-               P (makeif a s1 s2)
- TITI R_makeif_0 x x0 x1 y y0 y1 y2 y3
- TITI R_makeif_1 x x0 x1 y y0 y1 y2 y3
- TITI R_makeif_2 x x0 x1 y y0 y1
- TITI R_makeif_3 x x0 x1 y
- COQC cfrontend/ClightBigstep.v
- COQC cfrontend/SimplLocals.v
- COQC cfrontend/Csharpminor.v
- COQC cfrontend/SimplExprspec.v
- COQC cfrontend/SimplLocalsproof.v
- COQC cfrontend/Cshmgen.v
- COQC cfrontend/Cminorgen.v
- COQC backend/CminorSel.v
- COQC backend/RTL.v
- COQC ia32/Machregs.v
- COQC cfrontend/Cexec.v
- COQC cfrontend/Cshmgenproof.v
- COQC cfrontend/Cminorgenproof.v
- COQC ia32/SelectOp.v
- COQC backend/RTLgen.v
- COQC backend/Locations.v
- COQC backend/Inlining.v
- COQC backend/Renumber.v
- princ_type := forall (w : world) (e : env)
-                 (P : mem -&gt;
-                      list (ident * type) -&gt; list val -&gt; option mem -&gt; Type),
-               (forall (m : mem) (l : list (ident * type)) (lv : list val),
-                l = nil -&gt; lv = nil -&gt; P m nil nil (Some m)) -&gt;
-               (forall (m : mem) (l : list (ident * type)) 
-                  (lv : list val) (id : ident) (ty : type)
-                  (params : list (ident * type)),
-                l = (id, ty) :: params -&gt;
-                forall (v1 : val) (lv0 : list val),
-                lv = v1 :: lv0 -&gt;
-                forall (b : block) (ty&#39; : type),
-                e ! id = Some (b, ty&#39;) -&gt;
-                forall _x : ty = ty&#39;,
-                type_eq ty ty&#39; = left _x -&gt;
-                forall (w&#39; : world) (t : trace) (m1 : mem),
-                do_assign_loc w ty m b Int.zero v1 = Some (w&#39;, t, m1) -&gt;
-                t = nil -&gt;
-                P m1 params lv0 (sem_bind_parameters w e m1 params lv0) -&gt;
-                P m ((id, ty) :: params) (v1 :: lv0)
-                  (sem_bind_parameters w e m1 params lv0)) -&gt;
-               (forall (m : mem) (l : list (ident * type)) 
-                  (lv : list val) (id : ident) (ty : type)
-                  (params : list (ident * type)),
-                l = (id, ty) :: params -&gt;
-                forall (v1 : val) (lv0 : list val),
-                lv = v1 :: lv0 -&gt;
-                forall (b : block) (ty&#39; : type),
-                e ! id = Some (b, ty&#39;) -&gt;
-                forall _x : ty = ty&#39;,
-                type_eq ty ty&#39; = left _x -&gt;
-                forall (w&#39; : world) (t : trace) (m1 : mem),
-                do_assign_loc w ty m b Int.zero v1 = Some (w&#39;, t, m1) -&gt;
-                forall _x0 : trace,
-                t = _x0 -&gt;
-                match _x0 with
-                | nil =&gt; False
-                | _ :: _ =&gt; True
-                end -&gt; P m ((id, ty) :: params) (v1 :: lv0) None) -&gt;
-               (forall (m : mem) (l : list (ident * type)) 
-                  (lv : list val) (id : ident) (ty : type)
-                  (params : list (ident * type)),
-                l = (id, ty) :: params -&gt;
-                forall (v1 : val) (lv0 : list val),
-                lv = v1 :: lv0 -&gt;
-                forall (b : block) (ty&#39; : type),
-                e ! id = Some (b, ty&#39;) -&gt;
-                forall _x : ty = ty&#39;,
-                type_eq ty ty&#39; = left _x -&gt;
-                do_assign_loc w ty m b Int.zero v1 = None -&gt;
-                P m ((id, ty) :: params) (v1 :: lv0) None) -&gt;
-               (forall (m : mem) (l : list (ident * type)) 
-                  (lv : list val) (id : ident) (ty : type)
-                  (params : list (ident * type)),
-                l = (id, ty) :: params -&gt;
-                forall (v1 : val) (lv0 : list val),
-                lv = v1 :: lv0 -&gt;
-                forall (b : block) (ty&#39; : type),
-                e ! id = Some (b, ty&#39;) -&gt;
-                forall _x : ty &lt;&gt; ty&#39;,
-                type_eq ty ty&#39; = right _x -&gt;
-                P m ((id, ty) :: params) (v1 :: lv0) None) -&gt;
-               (forall (m : mem) (l : list (ident * type)) 
-                  (lv : list val) (id : ident) (ty : type)
-                  (params : list (ident * type)),
-                l = (id, ty) :: params -&gt;
-                forall (v1 : val) (lv0 : list val),
-                lv = v1 :: lv0 -&gt;
-                e ! id = None -&gt; P m ((id, ty) :: params) (v1 :: lv0) None) -&gt;
-               (forall (m : mem) (l : list (ident * type)) 
-                  (lv : list val) (_x : list (ident * type)),
-                l = _x -&gt;
-                forall _x0 : list val,
-                lv = _x0 -&gt;
-                match _x with
-                | nil =&gt; match _x0 with
-                         | nil =&gt; False
-                         | _ :: _ =&gt; True
-                         end
-                | (_, _) :: _ =&gt;
-                    match _x0 with
-                    | nil =&gt; True
-                    | _ :: _ =&gt; False
-                    end
-                end -&gt; P m _x _x0 None) -&gt;
-               forall (m : mem) (l : list (ident * type)) (lv : list val),
-               P m l lv (sem_bind_parameters w e m l lv)
- TITI R_sem_bind_parameters_0 x x0 y y0 y1 y2 y3
- TITI R_sem_bind_parameters_1 x x0 y y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10 y11 y12
-        y13 y14 y15 y16 y17 y18 (sem_bind_parameters x x0 y16 y4 y7)
-        (y19 (sem_bind_parameters x x0 y16 y4 y7) eq_refl)
- TITI R_sem_bind_parameters_2 x x0 y y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10 y11 y12
-        y13 y14 y15 y16 y17 y18 y19 y20
- TITI R_sem_bind_parameters_3 x x0 y y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10 y11 y12
-        y13 y14
- TITI R_sem_bind_parameters_4 x x0 y y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10 y11 y12
-        y13
- TITI R_sem_bind_parameters_5 x x0 y y0 y1 y2 y3 y4 y5 y6 y7 y8 y9
- TITI R_sem_bind_parameters_6 x x0 y y0 y1 y2 y3 y4 y5 y6
- COQC backend/Liveness.v
- COQC backend/ValueDomain.v
- COQC backend/CSEdomain.v
- COQC cfrontend/SimplExprproof.v
- COQC backend/SelectDiv.v
- COQC backend/SelectLong.v
- princ_type := forall (lo : Z)
-                 (P : Z -&gt; ZMap.t acontent -&gt; ZMap.t acontent -&gt; Type),
-               (forall (hi : Z) (c : ZMap.t acontent) (_x : lo &lt;= hi),
-                zle lo hi = left _x -&gt;
-                P (hi - 1) (ZMap.set hi ACany c)
-                  (inval_after lo (hi - 1) (ZMap.set hi ACany c)) -&gt;
-                P hi c (inval_after lo (hi - 1) (ZMap.set hi ACany c))) -&gt;
-               (forall (hi : Z) (c : ZMap.t acontent) (_x : lo &gt; hi),
-                zle lo hi = right _x -&gt; P hi c c) -&gt;
-               forall (hi : Z) (c : ZMap.t acontent),
-               P hi c (inval_after lo hi c)
- TITI R_inval_after_0 x y y0 y1 y2
-        (inval_after x (y - 1) (ZMap.set y ACany y0))
-        (y3 (inval_after x (y - 1) (ZMap.set y ACany y0)) eq_refl)
- TITI R_inval_after_1 x y y0 y1 y2
- princ_type := forall (hi : Z)
-                 (P : Z -&gt; ZMap.t acontent -&gt; ZMap.t acontent -&gt; Type),
-               (forall (lo : Z) (c : ZMap.t acontent) (_x : lo &lt; hi),
-                zlt lo hi = left _x -&gt;
-                P (lo + 1) (inval_if hi lo c)
-                  (inval_before hi (lo + 1) (inval_if hi lo c)) -&gt;
-                P lo c (inval_before hi (lo + 1) (inval_if hi lo c))) -&gt;
-               (forall (lo : Z) (c : ZMap.t acontent) (_x : lo &gt;= hi),
-                zlt lo hi = right _x -&gt; P lo c c) -&gt;
-               forall (lo : Z) (c : ZMap.t acontent),
-               P lo c (inval_before hi lo c)
- TITI R_inval_before_0 x y y0 y1 y2 (inval_before x (y + 1) (inval_if x y y0))
-        (y3 (inval_before x (y + 1) (inval_if x y y0)) eq_refl)
- TITI R_inval_before_1 x y y0 y1 y2
- COQC ia32/SelectOpproof.v
- COQC backend/RTLgenspec.v
- COQC ia32/standard/Conventions1.v
- COQC backend/Inliningspec.v
- COQC backend/Renumberproof.v
- COQC ia32/ValueAOp.v
- COQC ia32/ConstpropOp.v
- COQC ia32/CombineOp.v
- princ_type := forall (x : valnum)
-                 (P : option (condition * list valnum) -&gt; Type),
-               (forall (c : condition) (ys : list CSEdomain.valnum),
-                get x = Some (Op (Ocmp c) ys) -&gt; P (Some (c, ys))) -&gt;
-               (forall (n : int) (ys : list CSEdomain.valnum),
-                get x = Some (Op (Oandimm n) ys) -&gt;
-                P (Some (Cmasknotzero n, ys))) -&gt;
-               (forall _x : option rhs,
-                get x = _x -&gt;
-                match _x with
-                | Some (Op Omove _) =&gt; True
-                | Some (Op (Ointconst _) _) =&gt; True
-                | Some (Op (Ofloatconst _) _) =&gt; True
-                | Some (Op (Oindirectsymbol _) _) =&gt; True
-                | Some (Op Ocast8signed _) =&gt; True
-                | Some (Op Ocast8unsigned _) =&gt; True
-                | Some (Op Ocast16signed _) =&gt; True
-                | Some (Op Ocast16unsigned _) =&gt; True
-                | Some (Op Oneg _) =&gt; True
-                | Some (Op Osub _) =&gt; True
-                | Some (Op Omul _) =&gt; True
-                | Some (Op (Omulimm _) _) =&gt; True
-                | Some (Op Omulhs _) =&gt; True
-                | Some (Op Omulhu _) =&gt; True
-                | Some (Op Odiv _) =&gt; True
-                | Some (Op Odivu _) =&gt; True
-                | Some (Op Omod _) =&gt; True
-                | Some (Op Omodu _) =&gt; True
-                | Some (Op Oand _) =&gt; True
-                | Some (Op (Oandimm _) _) =&gt; False
-                | Some (Op Oor _) =&gt; True
-                | Some (Op (Oorimm _) _) =&gt; True
-                | Some (Op Oxor _) =&gt; True
-                | Some (Op (Oxorimm _) _) =&gt; True
-                | Some (Op Oshl _) =&gt; True
-                | Some (Op (Oshlimm _) _) =&gt; True
-                | Some (Op Oshr _) =&gt; True
-                | Some (Op (Oshrimm _) _) =&gt; True
-                | Some (Op (Oshrximm _) _) =&gt; True
-                | Some (Op Oshru _) =&gt; True
-                | Some (Op (Oshruimm _) _) =&gt; True
-                | Some (Op (Ororimm _) _) =&gt; True
-                | Some (Op (Oshldimm _) _) =&gt; True
-                | Some (Op (Olea _) _) =&gt; True
-                | Some (Op Onegf _) =&gt; True
-                | Some (Op Oabsf _) =&gt; True
-                | Some (Op Oaddf _) =&gt; True
-                | Some (Op Osubf _) =&gt; True
-                | Some (Op Omulf _) =&gt; True
-                | Some (Op Odivf _) =&gt; True
-                | Some (Op Osingleoffloat _) =&gt; True
-                | Some (Op Ointoffloat _) =&gt; True
-                | Some (Op Ofloatofint _) =&gt; True
-                | Some (Op Omakelong _) =&gt; True
-                | Some (Op Olowlong _) =&gt; True
-                | Some (Op Ohighlong _) =&gt; True
-                | Some (Op (Ocmp _) _) =&gt; False
-                | Some (Load _ _ _) =&gt; True
-                | None =&gt; True
-                end -&gt; P None) -&gt; P (combine_compimm_ne_0 x)
- TITI R_combine_compimm_ne_0_0 x y y0 y1
- TITI R_combine_compimm_ne_0_1 x y y0 y1
- TITI R_combine_compimm_ne_0_2 x y y0 y1
- princ_type := forall (x : valnum)
-                 (P : option (condition * list valnum) -&gt; Type),
-               (forall (c : condition) (ys : list CSEdomain.valnum),
-                get x = Some (Op (Ocmp c) ys) -&gt;
-                P (Some (negate_condition c, ys))) -&gt;
-               (forall (n : int) (ys : list CSEdomain.valnum),
-                get x = Some (Op (Oandimm n) ys) -&gt; P (Some (Cmaskzero n, ys))) -&gt;
-               (forall _x : option rhs,
-                get x = _x -&gt;
-                match _x with
-                | Some (Op Omove _) =&gt; True
-                | Some (Op (Ointconst _) _) =&gt; True
-                | Some (Op (Ofloatconst _) _) =&gt; True
-                | Some (Op (Oindirectsymbol _) _) =&gt; True
-                | Some (Op Ocast8signed _) =&gt; True
-                | Some (Op Ocast8unsigned _) =&gt; True
-                | Some (Op Ocast16signed _) =&gt; True
-                | Some (Op Ocast16unsigned _) =&gt; True
-                | Some (Op Oneg _) =&gt; True
-                | Some (Op Osub _) =&gt; True
-                | Some (Op Omul _) =&gt; True
-                | Some (Op (Omulimm _) _) =&gt; True
-                | Some (Op Omulhs _) =&gt; True
-                | Some (Op Omulhu _) =&gt; True
-                | Some (Op Odiv _) =&gt; True
-                | Some (Op Odivu _) =&gt; True
-                | Some (Op Omod _) =&gt; True
-                | Some (Op Omodu _) =&gt; True
-                | Some (Op Oand _) =&gt; True
-                | Some (Op (Oandimm _) _) =&gt; False
-                | Some (Op Oor _) =&gt; True
-                | Some (Op (Oorimm _) _) =&gt; True
-                | Some (Op Oxor _) =&gt; True
-                | Some (Op (Oxorimm _) _) =&gt; True
-                | Some (Op Oshl _) =&gt; True
-                | Some (Op (Oshlimm _) _) =&gt; True
-                | Some (Op Oshr _) =&gt; True
-                | Some (Op (Oshrimm _) _) =&gt; True
-                | Some (Op (Oshrximm _) _) =&gt; True
-                | Some (Op Oshru _) =&gt; True
-                | Some (Op (Oshruimm _) _) =&gt; True
-                | Some (Op (Ororimm _) _) =&gt; True
-                | Some (Op (Oshldimm _) _) =&gt; True
-                | Some (Op (Olea _) _) =&gt; True
-                | Some (Op Onegf _) =&gt; True
-                | Some (Op Oabsf _) =&gt; True
-                | Some (Op Oaddf _) =&gt; True
-                | Some (Op Osubf _) =&gt; True
-                | Some (Op Omulf _) =&gt; True
-                | Some (Op Odivf _) =&gt; True
-                | Some (Op Osingleoffloat _) =&gt; True
-                | Some (Op Ointoffloat _) =&gt; True
-                | Some (Op Ofloatofint _) =&gt; True
-                | Some (Op Omakelong _) =&gt; True
-                | Some (Op Olowlong _) =&gt; True
-                | Some (Op Ohighlong _) =&gt; True
-                | Some (Op (Ocmp _) _) =&gt; False
-                | Some (Load _ _ _) =&gt; True
-                | None =&gt; True
-                end -&gt; P None) -&gt; P (combine_compimm_eq_0 x)
- TITI R_combine_compimm_eq_0_0 x y y0 y1
- TITI R_combine_compimm_eq_0_1 x y y0 y1
- TITI R_combine_compimm_eq_0_2 x y y0 y1
- princ_type := forall (x : valnum)
-                 (P : option (condition * list valnum) -&gt; Type),
-               (forall (c : condition) (ys : list CSEdomain.valnum),
-                get x = Some (Op (Ocmp c) ys) -&gt; P (Some (c, ys))) -&gt;
-               (forall _x : option rhs,
-                get x = _x -&gt;
-                match _x with
-                | Some (Op Omove _) =&gt; True
-                | Some (Op (Ointconst _) _) =&gt; True
-                | Some (Op (Ofloatconst _) _) =&gt; True
-                | Some (Op (Oindirectsymbol _) _) =&gt; True
-                | Some (Op Ocast8signed _) =&gt; True
-                | Some (Op Ocast8unsigned _) =&gt; True
-                | Some (Op Ocast16signed _) =&gt; True
-                | Some (Op Ocast16unsigned _) =&gt; True
-                | Some (Op Oneg _) =&gt; True
-                | Some (Op Osub _) =&gt; True
-                | Some (Op Omul _) =&gt; True
-                | Some (Op (Omulimm _) _) =&gt; True
-                | Some (Op Omulhs _) =&gt; True
-                | Some (Op Omulhu _) =&gt; True
-                | Some (Op Odiv _) =&gt; True
-                | Some (Op Odivu _) =&gt; True
-                | Some (Op Omod _) =&gt; True
-                | Some (Op Omodu _) =&gt; True
-                | Some (Op Oand _) =&gt; True
-                | Some (Op (Oandimm _) _) =&gt; True
-                | Some (Op Oor _) =&gt; True
-                | Some (Op (Oorimm _) _) =&gt; True
-                | Some (Op Oxor _) =&gt; True
-                | Some (Op (Oxorimm _) _) =&gt; True
-                | Some (Op Oshl _) =&gt; True
-                | Some (Op (Oshlimm _) _) =&gt; True
-                | Some (Op Oshr _) =&gt; True
-                | Some (Op (Oshrimm _) _) =&gt; True
-                | Some (Op (Oshrximm _) _) =&gt; True
-                | Some (Op Oshru _) =&gt; True
-                | Some (Op (Oshruimm _) _) =&gt; True
-                | Some (Op (Ororimm _) _) =&gt; True
-                | Some (Op (Oshldimm _) _) =&gt; True
-                | Some (Op (Olea _) _) =&gt; True
-                | Some (Op Onegf _) =&gt; True
-                | Some (Op Oabsf _) =&gt; True
-                | Some (Op Oaddf _) =&gt; True
-                | Some (Op Osubf _) =&gt; True
-                | Some (Op Omulf _) =&gt; True
-                | Some (Op Odivf _) =&gt; True
-                | Some (Op Osingleoffloat _) =&gt; True
-                | Some (Op Ointoffloat _) =&gt; True
-                | Some (Op Ofloatofint _) =&gt; True
-                | Some (Op Omakelong _) =&gt; True
-                | Some (Op Olowlong _) =&gt; True
-                | Some (Op Ohighlong _) =&gt; True
-                | Some (Op (Ocmp _) _) =&gt; False
-                | Some (Load _ _ _) =&gt; True
-                | None =&gt; True
-                end -&gt; P None) -&gt; P (combine_compimm_eq_1 x)
- TITI R_combine_compimm_eq_1_0 x y y0 y1
- TITI R_combine_compimm_eq_1_1 x y y0 y1
- princ_type := forall (x : valnum)
-                 (P : option (condition * list valnum) -&gt; Type),
-               (forall (c : condition) (ys : list CSEdomain.valnum),
-                get x = Some (Op (Ocmp c) ys) -&gt;
-                P (Some (negate_condition c, ys))) -&gt;
-               (forall _x : option rhs,
-                get x = _x -&gt;
-                match _x with
-                | Some (Op Omove _) =&gt; True
-                | Some (Op (Ointconst _) _) =&gt; True
-                | Some (Op (Ofloatconst _) _) =&gt; True
-                | Some (Op (Oindirectsymbol _) _) =&gt; True
-                | Some (Op Ocast8signed _) =&gt; True
-                | Some (Op Ocast8unsigned _) =&gt; True
-                | Some (Op Ocast16signed _) =&gt; True
-                | Some (Op Ocast16unsigned _) =&gt; True
-                | Some (Op Oneg _) =&gt; True
-                | Some (Op Osub _) =&gt; True
-                | Some (Op Omul _) =&gt; True
-                | Some (Op (Omulimm _) _) =&gt; True
-                | Some (Op Omulhs _) =&gt; True
-                | Some (Op Omulhu _) =&gt; True
-                | Some (Op Odiv _) =&gt; True
-                | Some (Op Odivu _) =&gt; True
-                | Some (Op Omod _) =&gt; True
-                | Some (Op Omodu _) =&gt; True
-                | Some (Op Oand _) =&gt; True
-                | Some (Op (Oandimm _) _) =&gt; True
-                | Some (Op Oor _) =&gt; True
-                | Some (Op (Oorimm _) _) =&gt; True
-                | Some (Op Oxor _) =&gt; True
-                | Some (Op (Oxorimm _) _) =&gt; True
-                | Some (Op Oshl _) =&gt; True
-                | Some (Op (Oshlimm _) _) =&gt; True
-                | Some (Op Oshr _) =&gt; True
-                | Some (Op (Oshrimm _) _) =&gt; True
-                | Some (Op (Oshrximm _) _) =&gt; True
-                | Some (Op Oshru _) =&gt; True
-                | Some (Op (Oshruimm _) _) =&gt; True
-                | Some (Op (Ororimm _) _) =&gt; True
-                | Some (Op (Oshldimm _) _) =&gt; True
-                | Some (Op (Olea _) _) =&gt; True
-                | Some (Op Onegf _) =&gt; True
-                | Some (Op Oabsf _) =&gt; True
-                | Some (Op Oaddf _) =&gt; True
-                | Some (Op Osubf _) =&gt; True
-                | Some (Op Omulf _) =&gt; True
-                | Some (Op Odivf _) =&gt; True
-                | Some (Op Osingleoffloat _) =&gt; True
-                | Some (Op Ointoffloat _) =&gt; True
-                | Some (Op Ofloatofint _) =&gt; True
-                | Some (Op Omakelong _) =&gt; True
-                | Some (Op Olowlong _) =&gt; True
-                | Some (Op Ohighlong _) =&gt; True
-                | Some (Op (Ocmp _) _) =&gt; False
-                | Some (Load _ _ _) =&gt; True
-                | None =&gt; True
-                end -&gt; P None) -&gt; P (combine_compimm_ne_1 x)
- TITI R_combine_compimm_ne_1_0 x y y0 y1
- TITI R_combine_compimm_ne_1_1 x y y0 y1
- princ_type := forall
-                 P : condition -&gt;
-                     list valnum -&gt; option (condition * list valnum) -&gt; Type,
-               (forall (cond : condition) (args : list valnum) (n : int),
-                cond = Ccompimm Cne n -&gt;
-                forall x : valnum,
-                args = x :: nil -&gt;
-                forall _x : n = Int.zero,
-                Int.eq_dec n Int.zero = left _x -&gt;
-                P (Ccompimm Cne n) (x :: nil) (combine_compimm_ne_0 x)) -&gt;
-               (forall (cond : condition) (args : list valnum) (n : int),
-                cond = Ccompimm Cne n -&gt;
-                forall x : valnum,
-                args = x :: nil -&gt;
-                forall _x : n &lt;&gt; Int.zero,
-                Int.eq_dec n Int.zero = right _x -&gt;
-                forall _x0 : n = Int.one,
-                Int.eq_dec n Int.one = left _x0 -&gt;
-                P (Ccompimm Cne n) (x :: nil) (combine_compimm_ne_1 x)) -&gt;
-               (forall (cond : condition) (args : list valnum) (n : int),
-                cond = Ccompimm Cne n -&gt;
-                forall x : valnum,
-                args = x :: nil -&gt;
-                forall _x : n &lt;&gt; Int.zero,
-                Int.eq_dec n Int.zero = right _x -&gt;
-                forall _x0 : n &lt;&gt; Int.one,
-                Int.eq_dec n Int.one = right _x0 -&gt;
-                P (Ccompimm Cne n) (x :: nil) None) -&gt;
-               (forall (cond : condition) (args : list valnum) (n : int),
-                cond = Ccompimm Ceq n -&gt;
-                forall x : valnum,
-                args = x :: nil -&gt;
-                forall _x : n = Int.zero,
-                Int.eq_dec n Int.zero = left _x -&gt;
-                P (Ccompimm Ceq n) (x :: nil) (combine_compimm_eq_0 x)) -&gt;
-               (forall (cond : condition) (args : list valnum) (n : int),
-                cond = Ccompimm Ceq n -&gt;
-                forall x : valnum,
-                args = x :: nil -&gt;
-                forall _x : n &lt;&gt; Int.zero,
-                Int.eq_dec n Int.zero = right _x -&gt;
-                forall _x0 : n = Int.one,
-                Int.eq_dec n Int.one = left _x0 -&gt;
-                P (Ccompimm Ceq n) (x :: nil) (combine_compimm_eq_1 x)) -&gt;
-               (forall (cond : condition) (args : list valnum) (n : int),
-                cond = Ccompimm Ceq n -&gt;
-                forall x : valnum,
-                args = x :: nil -&gt;
-                forall _x : n &lt;&gt; Int.zero,
-                Int.eq_dec n Int.zero = right _x -&gt;
-                forall _x0 : n &lt;&gt; Int.one,
-                Int.eq_dec n Int.one = right _x0 -&gt;
-                P (Ccompimm Ceq n) (x :: nil) None) -&gt;
-               (forall (cond : condition) (args : list valnum) (n : int),
-                cond = Ccompuimm Cne n -&gt;
-                forall x : valnum,
-                args = x :: nil -&gt;
-                forall _x : n = Int.zero,
-                Int.eq_dec n Int.zero = left _x -&gt;
-                P (Ccompuimm Cne n) (x :: nil) (combine_compimm_ne_0 x)) -&gt;
-               (forall (cond : condition) (args : list valnum) (n : int),
-                cond = Ccompuimm Cne n -&gt;
-                forall x : valnum,
-                args = x :: nil -&gt;
-                forall _x : n &lt;&gt; Int.zero,
-                Int.eq_dec n Int.zero = right _x -&gt;
-                forall _x0 : n = Int.one,
-                Int.eq_dec n Int.one = left _x0 -&gt;
-                P (Ccompuimm Cne n) (x :: nil) (combine_compimm_ne_1 x)) -&gt;
-               (forall (cond : condition) (args : list valnum) (n : int),
-                cond = Ccompuimm Cne n -&gt;
-                forall x : valnum,
-                args = x :: nil -&gt;
-                forall _x : n &lt;&gt; Int.zero,
-                Int.eq_dec n Int.zero = right _x -&gt;
-                forall _x0 : n &lt;&gt; Int.one,
-                Int.eq_dec n Int.one = right _x0 -&gt;
-                P (Ccompuimm Cne n) (x :: nil) None) -&gt;
-               (forall (cond : condition) (args : list valnum) (n : int),
-                cond = Ccompuimm Ceq n -&gt;
-                forall x : valnum,
-                args = x :: nil -&gt;
-                forall _x : n = Int.zero,
-                Int.eq_dec n Int.zero = left _x -&gt;
-                P (Ccompuimm Ceq n) (x :: nil) (combine_compimm_eq_0 x)) -&gt;
-               (forall (cond : condition) (args : list valnum) (n : int),
-                cond = Ccompuimm Ceq n -&gt;
-                forall x : valnum,
-                args = x :: nil -&gt;
-                forall _x : n &lt;&gt; Int.zero,
-                Int.eq_dec n Int.zero = right _x -&gt;
-                forall _x0 : n = Int.one,
-                Int.eq_dec n Int.one = left _x0 -&gt;
-                P (Ccompuimm Ceq n) (x :: nil) (combine_compimm_eq_1 x)) -&gt;
-               (forall (cond : condition) (args : list valnum) (n : int),
-                cond = Ccompuimm Ceq n -&gt;
-                forall x : valnum,
-                args = x :: nil -&gt;
-                forall _x : n &lt;&gt; Int.zero,
-                Int.eq_dec n Int.zero = right _x -&gt;
-                forall _x0 : n &lt;&gt; Int.one,
-                Int.eq_dec n Int.one = right _x0 -&gt;
-                P (Ccompuimm Ceq n) (x :: nil) None) -&gt;
-               (forall (cond : condition) (args : list valnum)
-                  (_x : condition),
-                cond = _x -&gt;
-                forall _x0 : list valnum,
-                args = _x0 -&gt;
-                match _x with
-                | Ccomp _ =&gt; True
-                | Ccompu _ =&gt; True
-                | Ccompimm Ceq _ =&gt;
-                    match _x0 with
-                    | nil =&gt; True
-                    | _ :: nil =&gt; False
-                    | _ :: _ :: _ =&gt; True
-                    end
-                | Ccompimm Cne _ =&gt;
-                    match _x0 with
-                    | nil =&gt; True
-                    | _ :: nil =&gt; False
-                    | _ :: _ :: _ =&gt; True
-                    end
-                | Ccompimm Clt _ =&gt; True
-                | Ccompimm Cle _ =&gt; True
-                | Ccompimm Cgt _ =&gt; True
-                | Ccompimm Cge _ =&gt; True
-                | Ccompuimm Ceq _ =&gt;
-                    match _x0 with
-                    | nil =&gt; True
-                    | _ :: nil =&gt; False
-                    | _ :: _ :: _ =&gt; True
-                    end
-                | Ccompuimm Cne _ =&gt;
-                    match _x0 with
-                    | nil =&gt; True
-                    | _ :: nil =&gt; False
-                    | _ :: _ :: _ =&gt; True
-                    end
-                | Ccompuimm Clt _ =&gt; True
-                | Ccompuimm Cle _ =&gt; True
-                | Ccompuimm Cgt _ =&gt; True
-                | Ccompuimm Cge _ =&gt; True
-                | Ccompf _ =&gt; True
-                | Cnotcompf _ =&gt; True
-                | Cmaskzero _ =&gt; True
-                | Cmasknotzero _ =&gt; True
-                end -&gt; P _x _x0 None) -&gt;
-               forall (cond : condition) (args : list valnum),
-               P cond args (combine_cond cond args)
- TITI R_combine_cond_0 y y0 y1 y2 y3 y4 y5 y6
- TITI R_combine_cond_1 y y0 y1 y2 y3 y4 y5 y6 y7 y8
- TITI R_combine_cond_2 y y0 y1 y2 y3 y4 y5 y6 y7 y8
- TITI R_combine_cond_3 y y0 y1 y2 y3 y4 y5 y6
- TITI R_combine_cond_4 y y0 y1 y2 y3 y4 y5 y6 y7 y8
- TITI R_combine_cond_5 y y0 y1 y2 y3 y4 y5 y6 y7 y8
- TITI R_combine_cond_6 y y0 y1 y2 y3 y4 y5 y6
- TITI R_combine_cond_7 y y0 y1 y2 y3 y4 y5 y6 y7 y8
- TITI R_combine_cond_8 y y0 y1 y2 y3 y4 y5 y6 y7 y8
- TITI R_combine_cond_9 y y0 y1 y2 y3 y4 y5 y6
- TITI R_combine_cond_10 y y0 y1 y2 y3 y4 y5 y6 y7 y8
- TITI R_combine_cond_11 y y0 y1 y2 y3 y4 y5 y6 y7 y8
- TITI R_combine_cond_12 y y0 y1 y2 y3 y4 y5
- princ_type := forall
-                 P : addressing -&gt;
-                     list valnum -&gt; option (addressing * list valnum) -&gt; Type,
-               (forall (addr : addressing) (args : list valnum) (n : int),
-                addr = Aindexed n -&gt;
-                forall x : valnum,
-                args = x :: nil -&gt;
-                forall (a : addressing) (ys : list CSEdomain.valnum),
-                get x = Some (Op (Olea a) ys) -&gt;
-                P (Aindexed n) (x :: nil)
-                  (Some (offset_addressing_total a n, ys))) -&gt;
-               (forall (addr : addressing) (args : list valnum) (n : int),
-                addr = Aindexed n -&gt;
-                forall x : valnum,
-                args = x :: nil -&gt;
-                forall _x : option rhs,
-                get x = _x -&gt;
-                match _x with
-                | Some (Op Omove _) =&gt; True
-                | Some (Op (Ointconst _) _) =&gt; True
-                | Some (Op (Ofloatconst _) _) =&gt; True
-                | Some (Op (Oindirectsymbol _) _) =&gt; True
-                | Some (Op Ocast8signed _) =&gt; True
-                | Some (Op Ocast8unsigned _) =&gt; True
-                | Some (Op Ocast16signed _) =&gt; True
-                | Some (Op Ocast16unsigned _) =&gt; True
-                | Some (Op Oneg _) =&gt; True
-                | Some (Op Osub _) =&gt; True
-                | Some (Op Omul _) =&gt; True
-                | Some (Op (Omulimm _) _) =&gt; True
-                | Some (Op Omulhs _) =&gt; True
-                | Some (Op Omulhu _) =&gt; True
-                | Some (Op Odiv _) =&gt; True
-                | Some (Op Odivu _) =&gt; True
-                | Some (Op Omod _) =&gt; True
-                | Some (Op Omodu _) =&gt; True
-                | Some (Op Oand _) =&gt; True
-                | Some (Op (Oandimm _) _) =&gt; True
-                | Some (Op Oor _) =&gt; True
-                | Some (Op (Oorimm _) _) =&gt; True
-                | Some (Op Oxor _) =&gt; True
-                | Some (Op (Oxorimm _) _) =&gt; True
-                | Some (Op Oshl _) =&gt; True
-                | Some (Op (Oshlimm _) _) =&gt; True
-                | Some (Op Oshr _) =&gt; True
-                | Some (Op (Oshrimm _) _) =&gt; True
-                | Some (Op (Oshrximm _) _) =&gt; True
-                | Some (Op Oshru _) =&gt; True
-                | Some (Op (Oshruimm _) _) =&gt; True
-                | Some (Op (Ororimm _) _) =&gt; True
-                | Some (Op (Oshldimm _) _) =&gt; True
-                | Some (Op (Olea _) _) =&gt; False
-                | Some (Op Onegf _) =&gt; True
-                | Some (Op Oabsf _) =&gt; True
-                | Some (Op Oaddf _) =&gt; True
-                | Some (Op Osubf _) =&gt; True
-                | Some (Op Omulf _) =&gt; True
-                | Some (Op Odivf _) =&gt; True
-                | Some (Op Osingleoffloat _) =&gt; True
-                | Some (Op Ointoffloat _) =&gt; True
-                | Some (Op Ofloatofint _) =&gt; True
-                | Some (Op Omakelong _) =&gt; True
-                | Some (Op Olowlong _) =&gt; True
-                | Some (Op Ohighlong _) =&gt; True
-                | Some (Op (Ocmp _) _) =&gt; True
-                | Some (Load _ _ _) =&gt; True
-                | None =&gt; True
-                end -&gt; P (Aindexed n) (x :: nil) None) -&gt;
-               (forall (addr : addressing) (args : list valnum)
-                  (_x : addressing),
-                addr = _x -&gt;
-                forall _x0 : list valnum,
-                args = _x0 -&gt;
-                match _x with
-                | Aindexed _ =&gt;
-                    match _x0 with
-                    | nil =&gt; True
-                    | _ :: nil =&gt; False
-                    | _ :: _ :: _ =&gt; True
-                    end
-                | Aindexed2 _ =&gt; True
-                | Ascaled _ _ =&gt; True
-                | Aindexed2scaled _ _ =&gt; True
-                | Aglobal _ _ =&gt; True
-                | Abased _ _ =&gt; True
-                | Abasedscaled _ _ _ =&gt; True
-                | Ainstack _ =&gt; True
-                end -&gt; P _x _x0 None) -&gt;
-               forall (addr : addressing) (args : list valnum),
-               P addr args (combine_addr addr args)
- TITI R_combine_addr_0 y y0 y1 y2 y3 y4 y5 y6 y7
- TITI R_combine_addr_1 y y0 y1 y2 y3 y4 y5 y6 y7
- TITI R_combine_addr_2 y y0 y1 y2 y3 y4 y5
- princ_type := forall
-                 P : operation -&gt;
-                     list valnum -&gt; option (operation * list valnum) -&gt; Type,
-               (forall (op : operation) (args : list valnum)
-                  (addr : addressing),
-                op = Olea addr -&gt;
-                forall _x : list valnum,
-                args = _x -&gt;
-                forall (addr&#39; : addressing) (args&#39; : list valnum),
-                combine_addr addr args = Some (addr&#39;, args&#39;) -&gt;
-                P (Olea addr) _x (Some (Olea addr&#39;, args&#39;))) -&gt;
-               (forall (op : operation) (args : list valnum)
-                  (addr : addressing),
-                op = Olea addr -&gt;
-                forall _x : list valnum,
-                args = _x -&gt;
-                combine_addr addr args = None -&gt; P (Olea addr) _x None) -&gt;
-               (forall (op : operation) (args : list valnum) (n : int),
-                op = Oandimm n -&gt;
-                forall x : valnum,
-                args = x :: nil -&gt;
-                forall (m : int) (ys : list CSEdomain.valnum),
-                get x = Some (Op (Oandimm m) ys) -&gt;
-                P (Oandimm n) (x :: nil) (Some (Oandimm (Int.and m n), ys))) -&gt;
-               (forall (op : operation) (args : list valnum) (n : int),
-                op = Oandimm n -&gt;
-                forall x : valnum,
-                args = x :: nil -&gt;
-                forall _x : option rhs,
-                get x = _x -&gt;
-                match _x with
-                | Some (Op Omove _) =&gt; True
-                | Some (Op (Ointconst _) _) =&gt; True
-                | Some (Op (Ofloatconst _) _) =&gt; True
-                | Some (Op (Oindirectsymbol _) _) =&gt; True
-                | Some (Op Ocast8signed _) =&gt; True
-                | Some (Op Ocast8unsigned _) =&gt; True
-                | Some (Op Ocast16signed _) =&gt; True
-                | Some (Op Ocast16unsigned _) =&gt; True
-                | Some (Op Oneg _) =&gt; True
-                | Some (Op Osub _) =&gt; True
-                | Some (Op Omul _) =&gt; True
-                | Some (Op (Omulimm _) _) =&gt; True
-                | Some (Op Omulhs _) =&gt; True
-                | Some (Op Omulhu _) =&gt; True
-                | Some (Op Odiv _) =&gt; True
-                | Some (Op Odivu _) =&gt; True
-                | Some (Op Omod _) =&gt; True
-                | Some (Op Omodu _) =&gt; True
-                | Some (Op Oand _) =&gt; True
-                | Some (Op (Oandimm _) _) =&gt; False
-                | Some (Op Oor _) =&gt; True
-                | Some (Op (Oorimm _) _) =&gt; True
-                | Some (Op Oxor _) =&gt; True
-                | Some (Op (Oxorimm _) _) =&gt; True
-                | Some (Op Oshl _) =&gt; True
-                | Some (Op (Oshlimm _) _) =&gt; True
-                | Some (Op Oshr _) =&gt; True
-                | Some (Op (Oshrimm _) _) =&gt; True
-                | Some (Op (Oshrximm _) _) =&gt; True
-                | Some (Op Oshru _) =&gt; True
-                | Some (Op (Oshruimm _) _) =&gt; True
-                | Some (Op (Ororimm _) _) =&gt; True
-                | Some (Op (Oshldimm _) _) =&gt; True
-                | Some (Op (Olea _) _) =&gt; True
-                | Some (Op Onegf _) =&gt; True
-                | Some (Op Oabsf _) =&gt; True
-                | Some (Op Oaddf _) =&gt; True
-                | Some (Op Osubf _) =&gt; True
-                | Some (Op Omulf _) =&gt; True
-                | Some (Op Odivf _) =&gt; True
-                | Some (Op Osingleoffloat _) =&gt; True
-                | Some (Op Ointoffloat _) =&gt; True
-                | Some (Op Ofloatofint _) =&gt; True
-                | Some (Op Omakelong _) =&gt; True
-                | Some (Op Olowlong _) =&gt; True
-                | Some (Op Ohighlong _) =&gt; True
-                | Some (Op (Ocmp _) _) =&gt; True
-                | Some (Load _ _ _) =&gt; True
-                | None =&gt; True
-                end -&gt; P (Oandimm n) (x :: nil) None) -&gt;
-               (forall (op : operation) (args : list valnum) (n : int),
-                op = Oorimm n -&gt;
-                forall x : valnum,
-                args = x :: nil -&gt;
-                forall (m : int) (ys : list CSEdomain.valnum),
-                get x = Some (Op (Oorimm m) ys) -&gt;
-                P (Oorimm n) (x :: nil) (Some (Oorimm (Int.or m n), ys))) -&gt;
-               (forall (op : operation) (args : list valnum) (n : int),
-                op = Oorimm n -&gt;
-                forall x : valnum,
-                args = x :: nil -&gt;
-                forall _x : option rhs,
-                get x = _x -&gt;
-                match _x with
-                | Some (Op Omove _) =&gt; True
-                | Some (Op (Ointconst _) _) =&gt; True
-                | Some (Op (Ofloatconst _) _) =&gt; True
-                | Some (Op (Oindirectsymbol _) _) =&gt; True
-                | Some (Op Ocast8signed _) =&gt; True
-                | Some (Op Ocast8unsigned _) =&gt; True
-                | Some (Op Ocast16signed _) =&gt; True
-                | Some (Op Ocast16unsigned _) =&gt; True
-                | Some (Op Oneg _) =&gt; True
-                | Some (Op Osub _) =&gt; True
-                | Some (Op Omul _) =&gt; True
-                | Some (Op (Omulimm _) _) =&gt; True
-                | Some (Op Omulhs _) =&gt; True
-                | Some (Op Omulhu _) =&gt; True
-                | Some (Op Odiv _) =&gt; True
-                | Some (Op Odivu _) =&gt; True
-                | Some (Op Omod _) =&gt; True
-                | Some (Op Omodu _) =&gt; True
-                | Some (Op Oand _) =&gt; True
-                | Some (Op (Oandimm _) _) =&gt; True
-                | Some (Op Oor _) =&gt; True
-                | Some (Op (Oorimm _) _) =&gt; False
-                | Some (Op Oxor _) =&gt; True
-                | Some (Op (Oxorimm _) _) =&gt; True
-                | Some (Op Oshl _) =&gt; True
-                | Some (Op (Oshlimm _) _) =&gt; True
-                | Some (Op Oshr _) =&gt; True
-                | Some (Op (Oshrimm _) _) =&gt; True
-                | Some (Op (Oshrximm _) _) =&gt; True
-                | Some (Op Oshru _) =&gt; True
-                | Some (Op (Oshruimm _) _) =&gt; True
-                | Some (Op (Ororimm _) _) =&gt; True
-                | Some (Op (Oshldimm _) _) =&gt; True
-                | Some (Op (Olea _) _) =&gt; True
-                | Some (Op Onegf _) =&gt; True
-                | Some (Op Oabsf _) =&gt; True
-                | Some (Op Oaddf _) =&gt; True
-                | Some (Op Osubf _) =&gt; True
-                | Some (Op Omulf _) =&gt; True
-                | Some (Op Odivf _) =&gt; True
-                | Some (Op Osingleoffloat _) =&gt; True
-                | Some (Op Ointoffloat _) =&gt; True
-                | Some (Op Ofloatofint _) =&gt; True
-                | Some (Op Omakelong _) =&gt; True
-                | Some (Op Olowlong _) =&gt; True
-                | Some (Op Ohighlong _) =&gt; True
-                | Some (Op (Ocmp _) _) =&gt; True
-                | Some (Load _ _ _) =&gt; True
-                | None =&gt; True
-                end -&gt; P (Oorimm n) (x :: nil) None) -&gt;
-               (forall (op : operation) (args : list valnum) (n : int),
-                op = Oxorimm n -&gt;
-                forall x : valnum,
-                args = x :: nil -&gt;
-                forall (m : int) (ys : list CSEdomain.valnum),
-                get x = Some (Op (Oxorimm m) ys) -&gt;
-                P (Oxorimm n) (x :: nil) (Some (Oxorimm (Int.xor m n), ys))) -&gt;
-               (forall (op : operation) (args : list valnum) (n : int),
-                op = Oxorimm n -&gt;
-                forall x : valnum,
-                args = x :: nil -&gt;
-                forall _x : option rhs,
-                get x = _x -&gt;
-                match _x with
-                | Some (Op Omove _) =&gt; True
-                | Some (Op (Ointconst _) _) =&gt; True
-                | Some (Op (Ofloatconst _) _) =&gt; True
-                | Some (Op (Oindirectsymbol _) _) =&gt; True
-                | Some (Op Ocast8signed _) =&gt; True
-                | Some (Op Ocast8unsigned _) =&gt; True
-                | Some (Op Ocast16signed _) =&gt; True
-                | Some (Op Ocast16unsigned _) =&gt; True
-                | Some (Op Oneg _) =&gt; True
-                | Some (Op Osub _) =&gt; True
-                | Some (Op Omul _) =&gt; True
-                | Some (Op (Omulimm _) _) =&gt; True
-                | Some (Op Omulhs _) =&gt; True
-                | Some (Op Omulhu _) =&gt; True
-                | Some (Op Odiv _) =&gt; True
-                | Some (Op Odivu _) =&gt; True
-                | Some (Op Omod _) =&gt; True
-                | Some (Op Omodu _) =&gt; True
-                | Some (Op Oand _) =&gt; True
-                | Some (Op (Oandimm _) _) =&gt; True
-                | Some (Op Oor _) =&gt; True
-                | Some (Op (Oorimm _) _) =&gt; True
-                | Some (Op Oxor _) =&gt; True
-                | Some (Op (Oxorimm _) _) =&gt; False
-                | Some (Op Oshl _) =&gt; True
-                | Some (Op (Oshlimm _) _) =&gt; True
-                | Some (Op Oshr _) =&gt; True
-                | Some (Op (Oshrimm _) _) =&gt; True
-                | Some (Op (Oshrximm _) _) =&gt; True
-                | Some (Op Oshru _) =&gt; True
-                | Some (Op (Oshruimm _) _) =&gt; True
-                | Some (Op (Ororimm _) _) =&gt; True
-                | Some (Op (Oshldimm _) _) =&gt; True
-                | Some (Op (Olea _) _) =&gt; True
-                | Some (Op Onegf _) =&gt; True
-                | Some (Op Oabsf _) =&gt; True
-                | Some (Op Oaddf _) =&gt; True
-                | Some (Op Osubf _) =&gt; True
-                | Some (Op Omulf _) =&gt; True
-                | Some (Op Odivf _) =&gt; True
-                | Some (Op Osingleoffloat _) =&gt; True
-                | Some (Op Ointoffloat _) =&gt; True
-                | Some (Op Ofloatofint _) =&gt; True
-                | Some (Op Omakelong _) =&gt; True
-                | Some (Op Olowlong _) =&gt; True
-                | Some (Op Ohighlong _) =&gt; True
-                | Some (Op (Ocmp _) _) =&gt; True
-                | Some (Load _ _ _) =&gt; True
-                | None =&gt; True
-                end -&gt; P (Oxorimm n) (x :: nil) None) -&gt;
-               (forall (op : operation) (args : list valnum)
-                  (cond : condition),
-                op = Ocmp cond -&gt;
-                forall _x : list valnum,
-                args = _x -&gt;
-                forall (cond&#39; : condition) (args&#39; : list valnum),
-                combine_cond cond args = Some (cond&#39;, args&#39;) -&gt;
-                P (Ocmp cond) _x (Some (Ocmp cond&#39;, args&#39;))) -&gt;
-               (forall (op : operation) (args : list valnum)
-                  (cond : condition),
-                op = Ocmp cond -&gt;
-                forall _x : list valnum,
-                args = _x -&gt;
-                combine_cond cond args = None -&gt; P (Ocmp cond) _x None) -&gt;
-               (forall (op : operation) (args : list valnum) (_x : operation),
-                op = _x -&gt;
-                forall _x0 : list valnum,
-                args = _x0 -&gt;
-                match _x with
-                | Omove =&gt; True
-                | Ointconst _ =&gt; True
-                | Ofloatconst _ =&gt; True
-                | Oindirectsymbol _ =&gt; True
-                | Ocast8signed =&gt; True
-                | Ocast8unsigned =&gt; True
-                | Ocast16signed =&gt; True
-                | Ocast16unsigned =&gt; True
-                | Oneg =&gt; True
-                | Osub =&gt; True
-                | Omul =&gt; True
-                | Omulimm _ =&gt; True
-                | Omulhs =&gt; True
-                | Omulhu =&gt; True
-                | Odiv =&gt; True
-                | Odivu =&gt; True
-                | Omod =&gt; True
-                | Omodu =&gt; True
-                | Oand =&gt; True
-                | Oandimm _ =&gt;
-                    match _x0 with
-                    | nil =&gt; True
-                    | _ :: nil =&gt; False
-                    | _ :: _ :: _ =&gt; True
-                    end
-                | Oor =&gt; True
-                | Oorimm _ =&gt;
-                    match _x0 with
-                    | nil =&gt; True
-                    | _ :: nil =&gt; False
-                    | _ :: _ :: _ =&gt; True
-                    end
-                | Oxor =&gt; True
-                | Oxorimm _ =&gt;
-                    match _x0 with
-                    | nil =&gt; True
-                    | _ :: nil =&gt; False
-                    | _ :: _ :: _ =&gt; True
-                    end
-                | Oshl =&gt; True
-                | Oshlimm _ =&gt; True
-                | Oshr =&gt; True
-                | Oshrimm _ =&gt; True
-                | Oshrximm _ =&gt; True
-                | Oshru =&gt; True
-                | Oshruimm _ =&gt; True
-                | Ororimm _ =&gt; True
-                | Oshldimm _ =&gt; True
-                | Olea _ =&gt; False
-                | Onegf =&gt; True
-                | Oabsf =&gt; True
-                | Oaddf =&gt; True
-                | Osubf =&gt; True
-                | Omulf =&gt; True
-                | Odivf =&gt; True
-                | Osingleoffloat =&gt; True
-                | Ointoffloat =&gt; True
-                | Ofloatofint =&gt; True
-                | Omakelong =&gt; True
-                | Olowlong =&gt; True
-                | Ohighlong =&gt; True
-                | Ocmp _ =&gt; False
-                end -&gt; P _x _x0 None) -&gt;
-               forall (op : operation) (args : list valnum),
-               P op args (combine_op op args)
- TITI R_combine_op_0 y y0 y1 y2 y3 y4 y5 y6 y7
- TITI R_combine_op_1 y y0 y1 y2 y3 y4 y5
- TITI R_combine_op_2 y y0 y1 y2 y3 y4 y5 y6 y7
- TITI R_combine_op_3 y y0 y1 y2 y3 y4 y5 y6 y7
- TITI R_combine_op_4 y y0 y1 y2 y3 y4 y5 y6 y7
- TITI R_combine_op_5 y y0 y1 y2 y3 y4 y5 y6 y7
- TITI R_combine_op_6 y y0 y1 y2 y3 y4 y5 y6 y7
- TITI R_combine_op_7 y y0 y1 y2 y3 y4 y5 y6 y7
- TITI R_combine_op_8 y y0 y1 y2 y3 y4 y5 y6 y7
- TITI R_combine_op_9 y y0 y1 y2 y3 y4 y5
- TITI R_combine_op_10 y y0 y1 y2 y3 y4 y5
- COQC backend/NeedDomain.v
- COQC backend/Selection.v
- princ_type := forall P : expr -&gt; condexpr -&gt; Type,
-               (forall (e : expr) (c : condition) (el : exprlist),
-                e = Eop (Ocmp c) el -&gt; P (Eop (Ocmp c) el) (CEcond c el)) -&gt;
-               (forall (e : expr) (a : condexpr) (b c : expr),
-                e = Econdition a b c -&gt;
-                P b (condexpr_of_expr b) -&gt;
-                P c (condexpr_of_expr c) -&gt;
-                P (Econdition a b c)
-                  (CEcondition a (condexpr_of_expr b) (condexpr_of_expr c))) -&gt;
-               (forall e a b : expr,
-                e = Elet a b -&gt;
-                P b (condexpr_of_expr b) -&gt;
-                P (Elet a b) (CElet a (condexpr_of_expr b))) -&gt;
-               (forall e _x : expr,
-                e = _x -&gt;
-                match _x with
-                | Evar _ =&gt; True
-                | Eop Omove _ =&gt; True
-                | Eop (Ointconst _) _ =&gt; True
-                | Eop (Ofloatconst _) _ =&gt; True
-                | Eop (Oindirectsymbol _) _ =&gt; True
-                | Eop Ocast8signed _ =&gt; True
-                | Eop Ocast8unsigned _ =&gt; True
-                | Eop Ocast16signed _ =&gt; True
-                | Eop Ocast16unsigned _ =&gt; True
-                | Eop Oneg _ =&gt; True
-                | Eop Osub _ =&gt; True
-                | Eop Omul _ =&gt; True
-                | Eop (Omulimm _) _ =&gt; True
-                | Eop Omulhs _ =&gt; True
-                | Eop Omulhu _ =&gt; True
-                | Eop Odiv _ =&gt; True
-                | Eop Odivu _ =&gt; True
-                | Eop Omod _ =&gt; True
-                | Eop Omodu _ =&gt; True
-                | Eop Oand _ =&gt; True
-                | Eop (Oandimm _) _ =&gt; True
-                | Eop Oor _ =&gt; True
-                | Eop (Oorimm _) _ =&gt; True
-                | Eop Oxor _ =&gt; True
-                | Eop (Oxorimm _) _ =&gt; True
-                | Eop Oshl _ =&gt; True
-                | Eop (Oshlimm _) _ =&gt; True
-                | Eop Oshr _ =&gt; True
-                | Eop (Oshrimm _) _ =&gt; True
-                | Eop (Oshrximm _) _ =&gt; True
-                | Eop Oshru _ =&gt; True
-                | Eop (Oshruimm _) _ =&gt; True
-                | Eop (Ororimm _) _ =&gt; True
-                | Eop (Oshldimm _) _ =&gt; True
-                | Eop (Olea _) _ =&gt; True
-                | Eop Onegf _ =&gt; True
-                | Eop Oabsf _ =&gt; True
-                | Eop Oaddf _ =&gt; True
-                | Eop Osubf _ =&gt; True
-                | Eop Omulf _ =&gt; True
-                | Eop Odivf _ =&gt; True
-                | Eop Osingleoffloat _ =&gt; True
-                | Eop Ointoffloat _ =&gt; True
-                | Eop Ofloatofint _ =&gt; True
-                | Eop Omakelong _ =&gt; True
-                | Eop Olowlong _ =&gt; True
-                | Eop Ohighlong _ =&gt; True
-                | Eop (Ocmp _) _ =&gt; False
-                | Eload _ _ _ =&gt; True
-                | Econdition _ _ _ =&gt; False
-                | Elet _ _ =&gt; False
-                | Eletvar _ =&gt; True
-                | Ebuiltin _ _ =&gt; True
-                | Eexternal _ _ _ =&gt; True
-                end -&gt; P _x (CEcond (Ccompuimm Cne Int.zero) (e ::: Enil))) -&gt;
-               forall e : expr, P e (condexpr_of_expr e)
- TITI R_condexpr_of_expr_0 y y0 y1 y2
- TITI R_condexpr_of_expr_1 y y0 y1 y2 y3 (condexpr_of_expr y1)
-        (y4 (condexpr_of_expr y1) eq_refl) (condexpr_of_expr y2)
-        (y5 (condexpr_of_expr y2) eq_refl)
- TITI R_condexpr_of_expr_2 y y0 y1 y2 (condexpr_of_expr y1)
-        (y3 (condexpr_of_expr y1) eq_refl)
- TITI R_condexpr_of_expr_3 y y0 y1 y2
- COQC backend/SelectDivproof.v
- COQC backend/SelectLongproof.v
- COQC backend/RTLgenproof.v
- COQC backend/Conventions.v
- COQC backend/Inliningproof.v
- COQC backend/ValueAnalysis.v
- COQC ia32/ConstpropOpproof.v
- COQC backend/CSE.v
- COQC ia32/CombineOpproof.v
- COQC ia32/NeedOp.v
- COQC backend/LTL.v
- COQC backend/Selectionproof.v
- COQC backend/Tailcall.v
- COQC backend/RTLtyping.v
- COQC backend/Constprop.v
- COQC backend/CSEproof.v
- princ_type := forall (ae : AE.t)
-                 (P : external_function -&gt;
-                      list reg -&gt; external_function * list reg -&gt; Type),
-               (forall (ef : external_function) (args : list reg)
-                  (chunk : memory_chunk),
-                ef = EF_vload chunk -&gt;
-                forall r1 : reg,
-                args = r1 :: nil -&gt;
-                forall (symb : ident) (n1 : int),
-                areg ae r1 = Ptr (Gl symb n1) -&gt;
-                P (EF_vload chunk) (r1 :: nil)
-                  (EF_vload_global chunk symb n1, nil)) -&gt;
-               (forall (ef : external_function) (args : list reg)
-                  (chunk : memory_chunk),
-                ef = EF_vload chunk -&gt;
-                forall r1 : reg,
-                args = r1 :: nil -&gt;
-                forall _x : aval,
-                areg ae r1 = _x -&gt;
-                match _x with
-                | Vbot =&gt; True
-                | I _ =&gt; True
-                | Uns _ =&gt; True
-                | Sgn _ =&gt; True
-                | L _ =&gt; True
-                | F _ =&gt; True
-                | Fsingle =&gt; True
-                | Ptr Pbot =&gt; True
-                | Ptr (Gl _ _) =&gt; False
-                | Ptr (Glo _) =&gt; True
-                | Ptr Glob =&gt; True
-                | Ptr (Stk _) =&gt; True
-                | Ptr Stack =&gt; True
-                | Ptr Nonstack =&gt; True
-                | Ptr Ptop =&gt; True
-                | Ifptr _ =&gt; True
-                end -&gt; P (EF_vload chunk) (r1 :: nil) (ef, args)) -&gt;
-               (forall (ef : external_function) (args : list reg)
-                  (chunk : memory_chunk),
-                ef = EF_vstore chunk -&gt;
-                forall r1 r2 : reg,
-                args = r1 :: r2 :: nil -&gt;
-                forall (symb : ident) (n1 : int),
-                areg ae r1 = Ptr (Gl symb n1) -&gt;
-                P (EF_vstore chunk) (r1 :: r2 :: nil)
-                  (EF_vstore_global chunk symb n1, r2 :: nil)) -&gt;
-               (forall (ef : external_function) (args : list reg)
-                  (chunk : memory_chunk),
-                ef = EF_vstore chunk -&gt;
-                forall r1 r2 : reg,
-                args = r1 :: r2 :: nil -&gt;
-                forall _x : aval,
-                areg ae r1 = _x -&gt;
-                match _x with
-                | Vbot =&gt; True
-                | I _ =&gt; True
-                | Uns _ =&gt; True
-                | Sgn _ =&gt; True
-                | L _ =&gt; True
-                | F _ =&gt; True
-                | Fsingle =&gt; True
-                | Ptr Pbot =&gt; True
-                | Ptr (Gl _ _) =&gt; False
-                | Ptr (Glo _) =&gt; True
-                | Ptr Glob =&gt; True
-                | Ptr (Stk _) =&gt; True
-                | Ptr Stack =&gt; True
-                | Ptr Nonstack =&gt; True
-                | Ptr Ptop =&gt; True
-                | Ifptr _ =&gt; True
-                end -&gt; P (EF_vstore chunk) (r1 :: r2 :: nil) (ef, args)) -&gt;
-               (forall (ef : external_function) (args : list reg)
-                  (text : ident) (targs : list annot_arg),
-                ef = EF_annot text targs -&gt;
-                forall args0 : list reg,
-                args = args0 -&gt;
-                forall (targs&#39; : list annot_arg) (args&#39; : list reg),
-                annot_strength_reduction ae targs args0 = (targs&#39;, args&#39;) -&gt;
-                P (EF_annot text targs) args0 (EF_annot text targs&#39;, args&#39;)) -&gt;
-               (forall (ef : external_function) (args : list reg)
-                  (_x : external_function),
-                ef = _x -&gt;
-                forall _x0 : list reg,
-                args = _x0 -&gt;
-                match _x with
-                | EF_external _ _ =&gt; True
-                | EF_builtin _ _ =&gt; True
-                | EF_vload _ =&gt;
-                    match _x0 with
-                    | nil =&gt; True
-                    | _ :: nil =&gt; False
-                    | _ :: _ :: _ =&gt; True
-                    end
-                | EF_vstore _ =&gt;
-                    match _x0 with
-                    | nil =&gt; True
-                    | _ :: nil =&gt; True
-                    | _ :: _ :: nil =&gt; False
-                    | _ :: _ :: _ :: _ =&gt; True
-                    end
-                | EF_vload_global _ _ _ =&gt; True
-                | EF_vstore_global _ _ _ =&gt; True
-                | EF_malloc =&gt; True
-                | EF_free =&gt; True
-                | EF_memcpy _ _ =&gt; True
-                | EF_annot _ _ =&gt; False
-                | EF_annot_val _ _ =&gt; True
-                | EF_inline_asm _ =&gt; True
-                end -&gt; P _x _x0 (ef, args)) -&gt;
-               forall (ef : external_function) (args : list reg),
-               P ef args (builtin_strength_reduction ae ef args)
- TITI R_builtin_strength_reduction_0 x y y0 y1 y2 y3 y4 y5 y6 y7
- TITI R_builtin_strength_reduction_1 x y y0 y1 y2 y3 y4 y5 y6 y7
- TITI R_builtin_strength_reduction_2 x y y0 y1 y2 y3 y4 y5 y6 y7 y8
- TITI R_builtin_strength_reduction_3 x y y0 y1 y2 y3 y4 y5 y6 y7 y8
- TITI R_builtin_strength_reduction_4 x y y0 y1 y2 y3 y4 y5 y6 y7 y8
- TITI R_builtin_strength_reduction_5 x y y0 y1 y2 y3 y4 y5
- COQC backend/Deadcode.v
- COQC backend/Tunneling.v
- princ_type := forall (app : VA.t)
-                 (P : external_function -&gt;
-                      list reg -&gt; reg -&gt; NE.t -&gt; nmem -&gt; NA.t -&gt; Type),
-               (forall (ef : external_function) (args : list reg) 
-                  (res : reg) (ne : NE.t) (nm : nmem) 
-                  (chunk : memory_chunk),
-                ef = EF_vload chunk -&gt;
-                forall a1 : reg,
-                args = a1 :: nil -&gt;
-                P (EF_vload chunk) (a1 :: nil) res ne nm
-                  (add_needs_all args (kill res ne),
-                  nmem_add nm (aaddr app a1) (size_chunk chunk))) -&gt;
-               (forall (ef : external_function) (args : list reg) 
-                  (res : reg) (ne : NE.t) (nm : nmem) 
-                  (chunk : memory_chunk) (id : ident) 
-                  (ofs : int),
-                ef = EF_vload_global chunk id ofs -&gt;
-                args = nil -&gt;
-                P (EF_vload_global chunk id ofs) nil res ne nm
-                  (add_needs_all args (kill res ne),
-                  nmem_add nm (Gl id ofs) (size_chunk chunk))) -&gt;
-               (forall (ef : external_function) (args : list reg) 
-                  (res : reg) (ne : NE.t) (nm : nmem) 
-                  (chunk : memory_chunk),
-                ef = EF_vstore chunk -&gt;
-                forall a1 a2 : reg,
-                args = a1 :: a2 :: nil -&gt;
-                P (EF_vstore chunk) (a1 :: a2 :: nil) res ne nm
-                  (add_need_all a1
-                     (add_need a2 (store_argument chunk) (kill res ne)), nm)) -&gt;
-               (forall (ef : external_function) (args : list reg) 
-                  (res : reg) (ne : NE.t) (nm : nmem) 
-                  (chunk : memory_chunk) (id : ident) 
-                  (ofs : int),
-                ef = EF_vstore_global chunk id ofs -&gt;
-                forall a1 : reg,
-                args = a1 :: nil -&gt;
-                P (EF_vstore_global chunk id ofs) (a1 :: nil) res ne nm
-                  (add_need a1 (store_argument chunk) (kill res ne), nm)) -&gt;
-               (forall (ef : external_function) (args : list reg) 
-                  (res : reg) (ne : NE.t) (nm : nmem) 
-                  (sz al : Z),
-                ef = EF_memcpy sz al -&gt;
-                forall dst src : reg,
-                args = dst :: src :: nil -&gt;
-                nmem_contains nm (aaddr app dst) sz = true -&gt;
-                P (EF_memcpy sz al) (dst :: src :: nil) res ne nm
-                  (add_needs_all args (kill res ne),
-                  nmem_add (nmem_remove nm (aaddr app dst) sz) 
-                    (aaddr app src) sz)) -&gt;
-               (forall (ef : external_function) (args : list reg) 
-                  (res : reg) (ne : NE.t) (nm : nmem) 
-                  (sz al : Z),
-                ef = EF_memcpy sz al -&gt;
-                forall dst src : reg,
-                args = dst :: src :: nil -&gt;
-                nmem_contains nm (aaddr app dst) sz = false -&gt;
-                P (EF_memcpy sz al) (dst :: src :: nil) res ne nm (ne, nm)) -&gt;
-               (forall (ef : external_function) (args : list reg) 
-                  (res : reg) (ne : NE.t) (nm : nmem) 
-                  (txt : ident) (targs : list annot_arg),
-                ef = EF_annot txt targs -&gt;
-                forall _x : list reg,
-                args = _x -&gt;
-                P (EF_annot txt targs) _x res ne nm
-                  (add_needs_all args (kill res ne), nm)) -&gt;
-               (forall (ef : external_function) (args : list reg) 
-                  (res : reg) (ne : NE.t) (nm : nmem) 
-                  (txt : ident) (targ : typ),
-                ef = EF_annot_val txt targ -&gt;
-                forall _x : list reg,
-                args = _x -&gt;
-                P (EF_annot_val txt targ) _x res ne nm
-                  (add_needs_all args (kill res ne), nm)) -&gt;
-               (forall (ef : external_function) (args : list reg) 
-                  (res : reg) (ne : NE.t) (nm : nmem) 
-                  (_x : external_function),
-                ef = _x -&gt;
-                forall _x0 : list reg,
-                args = _x0 -&gt;
-                match _x with
-                | EF_external _ _ =&gt; True
-                | EF_builtin _ _ =&gt; True
-                | EF_vload _ =&gt;
-                    match _x0 with
-                    | nil =&gt; True
-                    | _ :: nil =&gt; False
-                    | _ :: _ :: _ =&gt; True
-                    end
-                | EF_vstore _ =&gt;
-                    match _x0 with
-                    | nil =&gt; True
-                    | _ :: nil =&gt; True
-                    | _ :: _ :: nil =&gt; False
-                    | _ :: _ :: _ :: _ =&gt; True
-                    end
-                | EF_vload_global _ _ _ =&gt;
-                    match _x0 with
-                    | nil =&gt; False
-                    | _ :: _ =&gt; True
-                    end
-                | EF_vstore_global _ _ _ =&gt;
-                    match _x0 with
-                    | nil =&gt; True
-                    | _ :: nil =&gt; False
-                    | _ :: _ :: _ =&gt; True
-                    end
-                | EF_malloc =&gt; True
-                | EF_free =&gt; True
-                | EF_memcpy _ _ =&gt;
-                    match _x0 with
-                    | nil =&gt; True
-                    | _ :: nil =&gt; True
-                    | _ :: _ :: nil =&gt; False
-                    | _ :: _ :: _ :: _ =&gt; True
-                    end
-                | EF_annot _ _ =&gt; False
-                | EF_annot_val _ _ =&gt; False
-                | EF_inline_asm _ =&gt; True
-                end -&gt;
-                P _x _x0 res ne nm
-                  (add_needs_all args (kill res ne), nmem_all)) -&gt;
-               forall (ef : external_function) (args : list reg) 
-                 (res : reg) (ne : NE.t) (nm : nmem),
-               P ef args res ne nm (transfer_builtin app ef args res ne nm)
- TITI R_transfer_builtin_0 x y y0 y1 y2 y3 y4 y5 y6 y7
- TITI R_transfer_builtin_1 x y y0 y1 y2 y3 y4 y5 y6 y7 y8
- TITI R_transfer_builtin_2 x y y0 y1 y2 y3 y4 y5 y6 y7 y8
- TITI R_transfer_builtin_3 x y y0 y1 y2 y3 y4 y5 y6 y7 y8 y9
- TITI R_transfer_builtin_4 x y y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10
- TITI R_transfer_builtin_5 x y y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10
- TITI R_transfer_builtin_6 x y y0 y1 y2 y3 y4 y5 y6 y7 y8
- TITI R_transfer_builtin_7 x y y0 y1 y2 y3 y4 y5 y6 y7 y8
- TITI R_transfer_builtin_8 x y y0 y1 y2 y3 y4 y5 y6 y7 y8
- COQC backend/Linear.v
- COQC backend/Tailcallproof.v
- COQC backend/Constpropproof.v
- COQC backend/Deadcodeproof.v
- COQC backend/Allocation.v
- COQC backend/Tunnelingproof.v
- COQC backend/Lineartyping.v
- COQC backend/Linearize.v
- COQC backend/CleanupLabels.v
- princ_type := forall
-                 P : list reg -&gt;
-                     list typ -&gt; list loc -&gt; eqs -&gt; option eqs -&gt; Type,
-               (forall (rl : list reg) (tyl : list typ) 
-                  (ll : list loc) (e : eqs),
-                rl = nil -&gt; tyl = nil -&gt; ll = nil -&gt; P nil nil nil e (Some e)) -&gt;
-               (forall (rl : list reg) (tyl : list typ) 
-                  (ll : list loc) (e : eqs) (r1 : reg) 
-                  (rl0 : list reg),
-                rl = r1 :: rl0 -&gt;
-                forall tyl0 : list typ,
-                tyl = Tlong :: tyl0 -&gt;
-                forall (l1 l2 : loc) (ll0 : list loc),
-                ll = l1 :: l2 :: ll0 -&gt;
-                P rl0 tyl0 ll0
-                  (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}
-                     (add_equation {| ekind := High; ereg := r1; eloc := l1 |}
-                        e))
-                  (add_equations_args rl0 tyl0 ll0
-                     (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}
-                        (add_equation
-                           {| ekind := High; ereg := r1; eloc := l1 |} e))) -&gt;
-                P (r1 :: rl0) (Tlong :: tyl0) (l1 :: l2 :: ll0) e
-                  (add_equations_args rl0 tyl0 ll0
-                     (add_equation {| ekind := Low; ereg := r1; eloc := l2 |}
-                        (add_equation
-                           {| ekind := High; ereg := r1; eloc := l1 |} e)))) -&gt;
-               (forall (rl : list reg) (tyl : list typ) 
-                  (ll : list loc) (e : eqs) (r1 : reg) 
-                  (rl0 : list reg),
-                rl = r1 :: rl0 -&gt;
-                forall tyl0 : list typ,
-                tyl = Tint :: tyl0 -&gt;
-                forall (l1 : loc) (ll0 : list loc),
-                ll = l1 :: ll0 -&gt;
-                P rl0 tyl0 ll0
-                  (add_equation {| ekind := Full; ereg := r1; eloc := l1 |} e)
-                  (add_equations_args rl0 tyl0 ll0
-                     (add_equation {| ekind := Full; ereg := r1; eloc := l1 |}
-                        e)) -&gt;
-                P (r1 :: rl0) (Tint :: tyl0) (l1 :: ll0) e
-                  (add_equations_args rl0 tyl0 ll0
-                     (add_equation {| ekind := Full; ereg := r1; eloc := l1 |}
-                        e))) -&gt;
-               (forall (rl : list reg) (tyl : list typ) 
-                  (ll : list loc) (e : eqs) (r1 : reg) 
-                  (rl0 : list reg),
-                rl = r1 :: rl0 -&gt;
-                forall tyl0 : list typ,
-                tyl = Tfloat :: tyl0 -&gt;
-                forall (l1 : loc) (ll0 : list loc),
-                ll = l1 :: ll0 -&gt;
-                P rl0 tyl0 ll0
-                  (add_equation {| ekind := Full; ereg := r1; eloc := l1 |} e)
-                  (add_equations_args rl0 tyl0 ll0
-                     (add_equation {| ekind := Full; ereg := r1; eloc := l1 |}
-                        e)) -&gt;
-                P (r1 :: rl0) (Tfloat :: tyl0) (l1 :: ll0) e
-                  (add_equations_args rl0 tyl0 ll0
-                     (add_equation {| ekind := Full; ereg := r1; eloc := l1 |}
-                        e))) -&gt;
-               (forall (rl : list reg) (tyl : list typ) 
-                  (ll : list loc) (e : eqs) (r1 : reg) 
-                  (rl0 : list reg),
-                rl = r1 :: rl0 -&gt;
-                forall tyl0 : list typ,
-                tyl = Tsingle :: tyl0 -&gt;
-                forall (l1 : loc) (ll0 : list loc),
-                ll = l1 :: ll0 -&gt;
-                P rl0 tyl0 ll0
-                  (add_equation {| ekind := Full; ereg := r1; eloc := l1 |} e)
-                  (add_equations_args rl0 tyl0 ll0
-                     (add_equation {| ekind := Full; ereg := r1; eloc := l1 |}
-                        e)) -&gt;
-                P (r1 :: rl0) (Tsingle :: tyl0) (l1 :: ll0) e
-                  (add_equations_args rl0 tyl0 ll0
-                     (add_equation {| ekind := Full; ereg := r1; eloc := l1 |}
-                        e))) -&gt;
-               (forall (rl : list reg) (tyl : list typ) 
-                  (ll : list loc) (e : eqs) (_x : list reg),
-                rl = _x -&gt;
-                forall _x0 : list typ,
-                tyl = _x0 -&gt;
-                forall _x1 : list loc,
-                ll = _x1 -&gt;
-                match _x with
-                | nil =&gt;
-                    match _x0 with
-                    | nil =&gt;
-                        match _x1 with
-                        | nil =&gt; False
-                        | _ :: _ =&gt; True
-                        end
-                    | _ :: _ =&gt; True
-                    end
-                | _ :: _ =&gt;
-                    match _x0 with
-                    | nil =&gt; True
-                    | Tint :: _ =&gt;
-                        match _x1 with
-                        | nil =&gt; True
-                        | _ :: _ =&gt; False
-                        end
-                    | Tfloat :: _ =&gt;
-                        match _x1 with
-                        | nil =&gt; True
-                        | _ :: _ =&gt; False
-                        end
-                    | Tlong :: _ =&gt;
-                        match _x1 with
-                        | nil =&gt; True
-                        | _ :: nil =&gt; True
-                        | _ :: _ :: _ =&gt; False
-                        end
-                    | Tsingle :: _ =&gt;
-                        match _x1 with
-                        | nil =&gt; True
-                        | _ :: _ =&gt; False
-                        end
-                    end
-                end -&gt; P _x _x0 _x1 e None) -&gt;
-               forall (rl : list reg) (tyl : list typ) 
-                 (ll : list loc) (e : eqs),
-               P rl tyl ll e (add_equations_args rl tyl ll e)
- TITI R_add_equations_args_0 y y0 y1 y2 y3 y4 y5
- TITI R_add_equations_args_1 y y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10 y11
-        (add_equations_args y4 y6 y10
-           (add_equation {| ekind := Low; ereg := y3; eloc := y9 |}
-              (add_equation {| ekind := High; ereg := y3; eloc := y8 |} y2)))
-        (y12
-           (add_equations_args y4 y6 y10
-              (add_equation {| ekind := Low; ereg := y3; eloc := y9 |}
-                 (add_equation {| ekind := High; ereg := y3; eloc := y8 |} y2)))
-           eq_refl)
- TITI R_add_equations_args_2 y y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10
-        (add_equations_args y4 y6 y9
-           (add_equation {| ekind := Full; ereg := y3; eloc := y8 |} y2))
-        (y11
-           (add_equations_args y4 y6 y9
-              (add_equation {| ekind := Full; ereg := y3; eloc := y8 |} y2))
-           eq_refl)
- TITI R_add_equations_args_3 y y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10
-        (add_equations_args y4 y6 y9
-           (add_equation {| ekind := Full; ereg := y3; eloc := y8 |} y2))
-        (y11
-           (add_equations_args y4 y6 y9
-              (add_equation {| ekind := Full; ereg := y3; eloc := y8 |} y2))
-           eq_refl)
- TITI R_add_equations_args_4 y y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10
-        (add_equations_args y4 y6 y9
-           (add_equation {| ekind := Full; ereg := y3; eloc := y8 |} y2))
-        (y11
-           (add_equations_args y4 y6 y9
-              (add_equation {| ekind := Full; ereg := y3; eloc := y8 |} y2))
-           eq_refl)
- TITI R_add_equations_args_5 y y0 y1 y2 y3 y4 y5 y6 y7 y8 y9
- princ_type := forall (r : reg)
-                 (P : option typ -&gt; list loc -&gt; eqs -&gt; option eqs -&gt; Type),
-               (forall (oty : option typ) (ll : list loc) (e : eqs),
-                oty = Some Tlong -&gt;
-                forall l1 l2 : loc,
-                ll = l1 :: l2 :: nil -&gt;
-                P (Some Tlong) (l1 :: l2 :: nil) e
-                  (Some
-                     (add_equation {| ekind := Low; ereg := r; eloc := l2 |}
-                        (add_equation
-                           {| ekind := High; ereg := r; eloc := l1 |} e)))) -&gt;
-               (forall (oty : option typ) (ll : list loc) (e : eqs),
-                oty = Some Tlong -&gt;
-                forall _x : list loc,
-                ll = _x -&gt;
-                match _x with
-                | nil =&gt; True
-                | _ :: nil =&gt; True
-                | _ :: _ :: nil =&gt; False
-                | _ :: _ :: _ :: _ =&gt; True
-                end -&gt; P (Some Tlong) _x e None) -&gt;
-               (forall (oty : option typ) (ll : list loc) 
-                  (e : eqs) (_x : option typ),
-                oty = _x -&gt;
-                match _x with
-                | Some Tint =&gt; True
-                | Some Tfloat =&gt; True
-                | Some Tlong =&gt; False
-                | Some Tsingle =&gt; True
-                | None =&gt; True
-                end -&gt;
-                forall l1 : loc,
-                ll = l1 :: nil -&gt;
-                P _x (l1 :: nil) e
-                  (Some
-                     (add_equation {| ekind := Full; ereg := r; eloc := l1 |}
-                        e))) -&gt;
-               (forall (oty : option typ) (ll : list loc) 
-                  (e : eqs) (_x : option typ),
-                oty = _x -&gt;
-                match _x with
-                | Some Tint =&gt; True
-                | Some Tfloat =&gt; True
-                | Some Tlong =&gt; False
-                | Some Tsingle =&gt; True
-                | None =&gt; True
-                end -&gt;
-                forall _x0 : list loc,
-                ll = _x0 -&gt;
-                match _x0 with
-                | nil =&gt; True
-                | _ :: nil =&gt; False
-                | _ :: _ :: _ =&gt; True
-                end -&gt; P _x _x0 e None) -&gt;
-               forall (oty : option typ) (ll : list loc) (e : eqs),
-               P oty ll e (add_equations_res r oty ll e)
- TITI R_add_equations_res_0 x y y0 y1 y2 y3 y4 y5
- TITI R_add_equations_res_1 x y y0 y1 y2 y3 y4 y5
- TITI R_add_equations_res_2 x y y0 y1 y2 y3 y4 y5 y6
- TITI R_add_equations_res_3 x y y0 y1 y2 y3 y4 y5 y6 y7
- princ_type := forall (r : reg)
-                 (P : option typ -&gt; list loc -&gt; eqs -&gt; option eqs -&gt; Type),
-               (forall (oty : option typ) (ll : list loc) (e : eqs),
-                oty = Some Tlong -&gt;
-                forall l1 l2 : loc,
-                ll = l1 :: l2 :: nil -&gt;
-                forall _x : Loc.diff l2 l1,
-                Loc.diff_dec l2 l1 = left _x -&gt;
-                P (Some Tlong) (l1 :: l2 :: nil) e
-                  (Some
-                     (remove_equation
-                        {| ekind := Low; ereg := r; eloc := l2 |}
-                        (remove_equation
-                           {| ekind := High; ereg := r; eloc := l1 |} e)))) -&gt;
-               (forall (oty : option typ) (ll : list loc) (e : eqs),
-                oty = Some Tlong -&gt;
-                forall l1 l2 : loc,
-                ll = l1 :: l2 :: nil -&gt;
-                forall _x : ~ Loc.diff l2 l1,
-                Loc.diff_dec l2 l1 = right _x -&gt;
-                P (Some Tlong) (l1 :: l2 :: nil) e None) -&gt;
-               (forall (oty : option typ) (ll : list loc) (e : eqs),
-                oty = Some Tlong -&gt;
-                forall _x : list loc,
-                ll = _x -&gt;
-                match _x with
-                | nil =&gt; True
-                | _ :: nil =&gt; True
-                | _ :: _ :: nil =&gt; False
-                | _ :: _ :: _ :: _ =&gt; True
-                end -&gt; P (Some Tlong) _x e None) -&gt;
-               (forall (oty : option typ) (ll : list loc) 
-                  (e : eqs) (_x : option typ),
-                oty = _x -&gt;
-                match _x with
-                | Some Tint =&gt; True
-                | Some Tfloat =&gt; True
-                | Some Tlong =&gt; False
-                | Some Tsingle =&gt; True
-                | None =&gt; True
-                end -&gt;
-                forall l1 : loc,
-                ll = l1 :: nil -&gt;
-                P _x (l1 :: nil) e
-                  (Some
-                     (remove_equation
-                        {| ekind := Full; ereg := r; eloc := l1 |} e))) -&gt;
-               (forall (oty : option typ) (ll : list loc) 
-                  (e : eqs) (_x : option typ),
-                oty = _x -&gt;
-                match _x with
-                | Some Tint =&gt; True
-                | Some Tfloat =&gt; True
-                | Some Tlong =&gt; False
-                | Some Tsingle =&gt; True
-                | None =&gt; True
-                end -&gt;
-                forall _x0 : list loc,
-                ll = _x0 -&gt;
-                match _x0 with
-                | nil =&gt; True
-                | _ :: nil =&gt; False
-                | _ :: _ :: _ =&gt; True
-                end -&gt; P _x _x0 e None) -&gt;
-               forall (oty : option typ) (ll : list loc) (e : eqs),
-               P oty ll e (remove_equations_res r oty ll e)
- TITI R_remove_equations_res_0 x y y0 y1 y2 y3 y4 y5 y6 y7
- TITI R_remove_equations_res_1 x y y0 y1 y2 y3 y4 y5 y6 y7
- TITI R_remove_equations_res_2 x y y0 y1 y2 y3 y4 y5
- TITI R_remove_equations_res_3 x y y0 y1 y2 y3 y4 y5 y6
- TITI R_remove_equations_res_4 x y y0 y1 y2 y3 y4 y5 y6 y7
- princ_type := forall
-                 P : list reg -&gt; list typ -&gt; list loc -&gt; eqs -&gt; bool -&gt; Type,
-               (forall (rparams : list reg) (tys : list typ)
-                  (lparams : list loc) (e : eqs),
-                rparams = nil -&gt;
-                tys = nil -&gt; lparams = nil -&gt; P nil nil nil e true) -&gt;
-               (forall (rparams : list reg) (tys : list typ)
-                  (lparams : list loc) (e : eqs) (r1 : reg) 
-                  (rl : list reg),
-                rparams = r1 :: rl -&gt;
-                forall tyl : list typ,
-                tys = Tlong :: tyl -&gt;
-                forall (l1 l2 : loc) (ll : list loc),
-                lparams = l1 :: l2 :: ll -&gt;
-                P rl tyl ll e (compat_entry rl tyl ll e) -&gt;
-                P (r1 :: rl) (Tlong :: tyl) (l1 :: l2 :: ll) e
-                  (compat_left2 r1 l1 l2 e &amp;&amp; compat_entry rl tyl ll e)) -&gt;
-               (forall (rparams : list reg) (tys : list typ)
-                  (lparams : list loc) (e : eqs) (r1 : reg) 
-                  (rl : list reg),
-                rparams = r1 :: rl -&gt;
-                forall tyl : list typ,
-                tys = Tint :: tyl -&gt;
-                forall (l1 : loc) (ll : list loc),
-                lparams = l1 :: ll -&gt;
-                P rl tyl ll e (compat_entry rl tyl ll e) -&gt;
-                P (r1 :: rl) (Tint :: tyl) (l1 :: ll) e
-                  (compat_left r1 l1 e &amp;&amp; compat_entry rl tyl ll e)) -&gt;
-               (forall (rparams : list reg) (tys : list typ)
-                  (lparams : list loc) (e : eqs) (r1 : reg) 
-                  (rl : list reg),
-                rparams = r1 :: rl -&gt;
-                forall tyl : list typ,
-                tys = Tfloat :: tyl -&gt;
-                forall (l1 : loc) (ll : list loc),
-                lparams = l1 :: ll -&gt;
-                P rl tyl ll e (compat_entry rl tyl ll e) -&gt;
-                P (r1 :: rl) (Tfloat :: tyl) (l1 :: ll) e
-                  (compat_left r1 l1 e &amp;&amp; compat_entry rl tyl ll e)) -&gt;
-               (forall (rparams : list reg) (tys : list typ)
-                  (lparams : list loc) (e : eqs) (r1 : reg) 
-                  (rl : list reg),
-                rparams = r1 :: rl -&gt;
-                forall tyl : list typ,
-                tys = Tsingle :: tyl -&gt;
-                forall (l1 : loc) (ll : list loc),
-                lparams = l1 :: ll -&gt;
-                P rl tyl ll e (compat_entry rl tyl ll e) -&gt;
-                P (r1 :: rl) (Tsingle :: tyl) (l1 :: ll) e
-                  (compat_left r1 l1 e &amp;&amp; compat_entry rl tyl ll e)) -&gt;
-               (forall (rparams : list reg) (tys : list typ)
-                  (lparams : list loc) (e : eqs) (_x : list reg),
-                rparams = _x -&gt;
-                forall _x0 : list typ,
-                tys = _x0 -&gt;
-                forall _x1 : list loc,
-                lparams = _x1 -&gt;
-                match _x with
-                | nil =&gt;
-                    match _x0 with
-                    | nil =&gt;
-                        match _x1 with
-                        | nil =&gt; False
-                        | _ :: _ =&gt; True
-                        end
-                    | _ :: _ =&gt; True
-                    end
-                | _ :: _ =&gt;
-                    match _x0 with
-                    | nil =&gt; True
-                    | Tint :: _ =&gt;
-                        match _x1 with
-                        | nil =&gt; True
-                        | _ :: _ =&gt; False
-                        end
-                    | Tfloat :: _ =&gt;
-                        match _x1 with
-                        | nil =&gt; True
-                        | _ :: _ =&gt; False
-                        end
-                    | Tlong :: _ =&gt;
-                        match _x1 with
-                        | nil =&gt; True
-                        | _ :: nil =&gt; True
-                        | _ :: _ :: _ =&gt; False
-                        end
-                    | Tsingle :: _ =&gt;
-                        match _x1 with
-                        | nil =&gt; True
-                        | _ :: _ =&gt; False
-                        end
-                    end
-                end -&gt; P _x _x0 _x1 e false) -&gt;
-               forall (rparams : list reg) (tys : list typ)
-                 (lparams : list loc) (e : eqs),
-               P rparams tys lparams e (compat_entry rparams tys lparams e)
- TITI R_compat_entry_0 y y0 y1 y2 y3 y4 y5
- TITI R_compat_entry_1 y y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10 y11
-        (compat_entry y4 y6 y10 y2) (y12 (compat_entry y4 y6 y10 y2) eq_refl)
- TITI R_compat_entry_2 y y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10
-        (compat_entry y4 y6 y9 y2) (y11 (compat_entry y4 y6 y9 y2) eq_refl)
- TITI R_compat_entry_3 y y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10
-        (compat_entry y4 y6 y9 y2) (y11 (compat_entry y4 y6 y9 y2) eq_refl)
- TITI R_compat_entry_4 y y0 y1 y2 y3 y4 y5 y6 y7 y8 y9 y10
-        (compat_entry y4 y6 y9 y2) (y11 (compat_entry y4 y6 y9 y2) eq_refl)
- TITI R_compat_entry_5 y y0 y1 y2 y3 y4 y5 y6 y7 y8 y9
- COQC backend/Bounds.v
- COQC backend/Linearizeproof.v
- COQC backend/CleanupLabelsproof.v
- COQC ia32/standard/Stacklayout.v
- COQC backend/Mach.v
- COQC ia32/Asm.v
- COQC backend/Allocproof.v
- COQC backend/Stacking.v
- COQC backend/Stackingproof.v
- COQC ia32/Asmgen.v
- COQC backend/Asmgenproof0.v
- COQC ia32/Asmgenproof1.v
- COQC ia32/Asmgenproof.v
- COQC driver/Compiler.v
- COQC driver/Complements.v
- make[1]: Leaving directory &#39;/home/bench/.opam/system/build/coq:contrib:compcert.dev&#39;
- make extraction
- make[1]: Entering directory &#39;/home/bench/.opam/system/build/coq:contrib:compcert.dev&#39;
- rm -f extraction/*.ml extraction/*.mli
- &quot;coqtop&quot;  -R lib compcert.lib  -R common compcert.common  -R backend compcert.backend  -R cfrontend compcert.cfrontend  -R driver compcert.driver  -R flocq compcert.flocq  -R exportclight compcert.exportclight -R ia32 compcert.ia32 -batch -load-vernac-source extraction/extraction.v
- Welcome to Coq cb98bc5265d8:/home/bench/.opam/system/build/coq.dev,master (148cf78a4d85ec56818a8ff00719a775670950b9)
- Fetching opaque proofs from disk for compcert.common.Subtyping
- Fetching opaque proofs from disk for compcert.backend.ValueDomain
- Fetching opaque proofs from disk for compcert.common.Globalenvs
- touch extraction/STAMP
- make[1]: Leaving directory &#39;/home/bench/.opam/system/build/coq:contrib:compcert.dev&#39;
- make ccomp
- make[1]: Entering directory &#39;/home/bench/.opam/system/build/coq:contrib:compcert.dev&#39;
- (echo let stdlib_path = &quot;\&quot;/usr/local/lib/compcert\&quot;&quot;; \
-          echo let prepro = &quot;\&quot;gcc -m32 -U__GNUC__ -E\&quot;&quot;; \
-          echo let asm = &quot;\&quot;gcc -m32 -c\&quot;&quot;; \
-          echo let linker = &quot;\&quot;gcc -m32\&quot;&quot;; \
-          echo let arch = &quot;\&quot;ia32\&quot;&quot;; \
-          echo let variant = &quot;\&quot;standard\&quot;&quot;; \
-          echo let system = &quot;\&quot;linux\&quot;&quot;; \
-          echo let has_runtime_lib = true; \
-          echo let asm_supports_cfi = true; \
-          version=`cat VERSION`; \
-          echo let version = &quot;\&quot;$version\&quot;&quot;) \
-         &gt; driver/Configuration.ml
- ocamlbuild -j 2 -no-hygiene -no-links -I lib -I common -I ia32/standard -I ia32 -I backend -I cfrontend -I driver -I flocq/Core -I flocq/Prop -I flocq/Calc -I flocq/Appli -I exportclight -I extraction -I cparser Driver.native \
-         &amp;&amp; rm -f ccomp &amp;&amp; ln -s _build/driver/Driver.native ccomp
- /usr/local/bin/ocamlopt.opt unix.cmxa -I /usr/local/lib/ocaml/ocamlbuild /usr/local/lib/ocaml/ocamlbuild/ocamlbuildlib.cmxa myocamlbuild.ml /usr/local/lib/ocaml/ocamlbuild/ocamlbuild.cmx -o myocamlbuild
- /usr/local/bin/ocamldep.opt -modules driver/Driver.ml &gt; driver/Driver.ml.depends
- /usr/local/bin/ocamldep.opt -modules cparser/Builtins.mli &gt; cparser/Builtins.mli.depends
- /usr/local/bin/ocamldep.opt -modules cparser/C.mli &gt; cparser/C.mli.depends
- /usr/local/bin/ocamldep.opt -modules cparser/Env.mli &gt; cparser/Env.mli.depends
- /usr/local/bin/ocamlc.opt -c -I cparser -I lib -I driver -I extraction -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o cparser/C.cmi cparser/C.mli
- /usr/local/bin/ocamlc.opt -c -I cparser -I lib -I driver -I extraction -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o cparser/Env.cmi cparser/Env.mli
- /usr/local/bin/ocamldep.opt -modules cfrontend/C2C.ml &gt; cfrontend/C2C.ml.depends
- /usr/local/bin/ocamldep.opt -modules extraction/AST.mli &gt; extraction/AST.mli.depends
- /usr/local/bin/ocamldep.opt -modules extraction/BinNums.mli &gt; extraction/BinNums.mli.depends
- /usr/local/bin/ocamldep.opt -modules extraction/Bool.mli &gt; extraction/Bool.mli.depends
- /usr/local/bin/ocamldep.opt -modules extraction/Coqlib.mli &gt; extraction/Coqlib.mli.depends
- /usr/local/bin/ocamldep.opt -modules extraction/BinInt.mli &gt; extraction/BinInt.mli.depends
- /usr/local/bin/ocamldep.opt -modules extraction/BinNat.mli &gt; extraction/BinNat.mli.depends
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/BinNums.cmi extraction/BinNums.mli
- /usr/local/bin/ocamldep.opt -modules extraction/BinPos.mli &gt; extraction/BinPos.mli.depends
- /usr/local/bin/ocamldep.opt -modules extraction/BinPosDef.mli &gt; extraction/BinPosDef.mli.depends
- /usr/local/bin/ocamldep.opt -modules extraction/Datatypes.mli &gt; extraction/Datatypes.mli.depends
- /usr/local/bin/ocamldep.opt -modules extraction/Nat.mli &gt; extraction/Nat.mli.depends
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/Datatypes.cmi extraction/Datatypes.mli
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/BinPosDef.cmi extraction/BinPosDef.mli
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/Nat.cmi extraction/Nat.mli
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/BinPos.cmi extraction/BinPos.mli
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/BinNat.cmi extraction/BinNat.mli
- /usr/local/bin/ocamldep.opt -modules extraction/List0.mli &gt; extraction/List0.mli.depends
- /usr/local/bin/ocamldep.opt -modules extraction/Specif.mli &gt; extraction/Specif.mli.depends
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/Specif.cmi extraction/Specif.mli
- /usr/local/bin/ocamldep.opt -modules extraction/ZArith_dec.mli &gt; extraction/ZArith_dec.mli.depends
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/BinInt.cmi extraction/BinInt.mli
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/List0.cmi extraction/List0.mli
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/ZArith_dec.cmi extraction/ZArith_dec.mli
- /usr/local/bin/ocamldep.opt -modules extraction/Errors.mli &gt; extraction/Errors.mli.depends
- /usr/local/bin/ocamldep.opt -modules extraction/Floats.mli &gt; extraction/Floats.mli.depends
- /usr/local/bin/ocamldep.opt -modules extraction/Archi.mli &gt; extraction/Archi.mli.depends
- /usr/local/bin/ocamldep.opt -modules extraction/Fappli_IEEE.mli &gt; extraction/Fappli_IEEE.mli.depends
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/Bool.cmi extraction/Bool.mli
- /usr/local/bin/ocamldep.opt -modules extraction/Fcalc_bracket.mli &gt; extraction/Fcalc_bracket.mli.depends
- /usr/local/bin/ocamldep.opt -modules extraction/Fcore_Zaux.mli &gt; extraction/Fcore_Zaux.mli.depends
- /usr/local/bin/ocamldep.opt -modules extraction/Zbool.mli &gt; extraction/Zbool.mli.depends
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/Fcore_Zaux.cmi extraction/Fcore_Zaux.mli
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/Zbool.cmi extraction/Zbool.mli
- /usr/local/bin/ocamldep.opt -modules extraction/Fcalc_round.mli &gt; extraction/Fcalc_round.mli.depends
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/Fcalc_bracket.cmi extraction/Fcalc_bracket.mli
- /usr/local/bin/ocamldep.opt -modules extraction/Fcore_FLT.mli &gt; extraction/Fcore_FLT.mli.depends
- /usr/local/bin/ocamldep.opt -modules extraction/Fcore_digits.mli &gt; extraction/Fcore_digits.mli.depends
- /usr/local/bin/ocamldep.opt -modules extraction/Zpower.mli &gt; extraction/Zpower.mli.depends
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/Fcalc_round.cmi extraction/Fcalc_round.mli
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/Fcore_FLT.cmi extraction/Fcore_FLT.mli
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/Fcore_digits.cmi extraction/Fcore_digits.mli
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/Zpower.cmi extraction/Zpower.mli
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/Fappli_IEEE.cmi extraction/Fappli_IEEE.mli
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/Coqlib.cmi extraction/Coqlib.mli
- /usr/local/bin/ocamldep.opt -modules extraction/Fappli_IEEE_bits.mli &gt; extraction/Fappli_IEEE_bits.mli.depends
- /usr/local/bin/ocamldep.opt -modules extraction/Integers.mli &gt; extraction/Integers.mli.depends
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/Archi.cmi extraction/Archi.mli
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/Fappli_IEEE_bits.cmi extraction/Fappli_IEEE_bits.mli
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/Integers.cmi extraction/Integers.mli
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/Errors.cmi extraction/Errors.mli
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/Floats.cmi extraction/Floats.mli
- /usr/local/bin/ocamlc.opt -c -I cparser -I lib -I driver -I extraction -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o cparser/Builtins.cmi cparser/Builtins.mli
- /usr/local/bin/ocamldep.opt -modules ia32/CBuiltins.ml &gt; ia32/CBuiltins.ml.depends
- /usr/local/bin/ocamldep.opt -modules lib/Camlcoq.ml &gt; lib/Camlcoq.ml.depends
- /usr/local/bin/ocamldep.opt -modules cparser/Ceval.mli &gt; cparser/Ceval.mli.depends
- /usr/local/bin/ocamldep.opt -modules driver/Clflags.ml &gt; driver/Clflags.ml.depends
- /usr/local/bin/ocamldep.opt -modules driver/Configuration.ml &gt; driver/Configuration.ml.depends
- /usr/local/bin/ocamlc.opt -c -I driver -I cparser -I lib -I extraction -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o driver/Configuration.cmo driver/Configuration.ml
- /usr/local/bin/ocamldep.opt -modules extraction/Cop.mli &gt; extraction/Cop.mli.depends
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/AST.cmi extraction/AST.mli
- /usr/local/bin/ocamldep.opt -modules extraction/Ctypes.mli &gt; extraction/Ctypes.mli.depends
- /usr/local/bin/ocamldep.opt -modules extraction/Memory.mli &gt; extraction/Memory.mli.depends
- /usr/local/bin/ocamldep.opt -modules extraction/Maps.mli &gt; extraction/Maps.mli.depends
- /usr/local/bin/ocamldep.opt -modules extraction/EquivDec.mli &gt; extraction/EquivDec.mli.depends
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/EquivDec.cmi extraction/EquivDec.mli
- /usr/local/bin/ocamldep.opt -modules extraction/Memdata.mli &gt; extraction/Memdata.mli.depends
- /usr/local/bin/ocamldep.opt -modules extraction/PeanoNat.mli &gt; extraction/PeanoNat.mli.depends
- /usr/local/bin/ocamldep.opt -modules extraction/Values.mli &gt; extraction/Values.mli.depends
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/PeanoNat.cmi extraction/PeanoNat.mli
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/Values.cmi extraction/Values.mli
- /usr/local/bin/ocamldep.opt -modules extraction/Memtype.mli &gt; extraction/Memtype.mli.depends
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/Maps.cmi extraction/Maps.mli
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/Memdata.cmi extraction/Memdata.mli
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/Memtype.cmi extraction/Memtype.mli
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/Ctypes.cmi extraction/Ctypes.mli
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/Memory.cmi extraction/Memory.mli
- /usr/local/bin/ocamldep.opt -modules cparser/Cprint.mli &gt; cparser/Cprint.mli.depends
- /usr/local/bin/ocamldep.opt -modules extraction/Csyntax.mli &gt; extraction/Csyntax.mli.depends
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/Cop.cmi extraction/Cop.mli
- /usr/local/bin/ocamldep.opt -modules cparser/Cutil.mli &gt; cparser/Cutil.mli.depends
- /usr/local/bin/ocamldep.opt -modules extraction/Initializers.mli &gt; extraction/Initializers.mli.depends
- /usr/local/bin/ocamlc.opt -c -I extraction -I cparser -I lib -I driver -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o extraction/Csyntax.cmi extraction/Csyntax.mli
- /usr/local/bin/ocamldep.opt -modules cparser/Machine.mli &gt; cparser/Machine.mli.depends
- /usr/local/bin/ocamldep.opt -modules common/Sections.mli &gt; common/Sections.mli.depends
- /usr/local/bin/ocamlc.opt -c -I ia32 -I cparser -I lib -I driver -I extraction -I common -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o ia32/CBuiltins.cmo ia32/CBuiltins.ml
- /usr/local/bin/ocamlc.opt -c -I lib -I cparser -I driver -I extraction -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o lib/Camlcoq.cmo lib/Camlcoq.ml
- /usr/local/bin/ocamlc.opt -c -I cparser -I lib -I driver -I extraction -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o cparser/Ceval.cmi cparser/Ceval.mli
- /usr/local/bin/ocamlc.opt -c -I driver -I cparser -I lib -I extraction -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o driver/Clflags.cmo driver/Clflags.ml
- /usr/local/bin/ocamlc.opt -c -I cparser -I lib -I driver -I extraction -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o cparser/Cprint.cmi cparser/Cprint.mli
- + /usr/local/bin/ocamlc.opt -c -I lib -I cparser -I driver -I extraction -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o lib/Camlcoq.cmo lib/Camlcoq.ml
- File &quot;lib/Camlcoq.ml&quot;, line 60, characters 12-19:
- Error: Unbound value Pos.sub
- Command exited with code 2.
- Makefile:148: recipe for target &#39;ccomp&#39; failed
- make[1]: Leaving directory &#39;/home/bench/.opam/system/build/coq:contrib:compcert.dev&#39;
- Makefile:128: recipe for target &#39;all&#39; failed
- make[1]: *** [ccomp] Error 10
- make: *** [all] Error 2
[ERROR] The compilation of coq:contrib:compcert failed at &quot;make -j4&quot;.
#=== ERROR while installing coq:contrib:compcert.dev ==========================#
# opam-version         1.2.1
# os                   linux
# command              make -j4
# path                 /home/bench/.opam/system/build/coq:contrib:compcert.dev
# compiler             system (4.02.1)
# exit-code            2
# env-file             /home/bench/.opam/system/build/coq:contrib:compcert.dev/coq:contrib:compcert-29773-ad8886.env
# stdout-file          /home/bench/.opam/system/build/coq:contrib:compcert.dev/coq:contrib:compcert-29773-ad8886.out
# stderr-file          /home/bench/.opam/system/build/coq:contrib:compcert.dev/coq:contrib:compcert-29773-ad8886.err
### stdout ###
# [...]
# /usr/local/bin/ocamlc.opt -c -I cparser -I lib -I driver -I extraction -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o cparser/Ceval.cmi cparser/Ceval.mli
# /usr/local/bin/ocamlc.opt -c -I driver -I cparser -I lib -I extraction -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o driver/Clflags.cmo driver/Clflags.ml
# /usr/local/bin/ocamlc.opt -c -I cparser -I lib -I driver -I extraction -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o cparser/Cprint.cmi cparser/Cprint.mli
# + /usr/local/bin/ocamlc.opt -c -I lib -I cparser -I driver -I extraction -I common -I ia32 -I cfrontend -I exportclight -I backend -I ia32/standard -I flocq/Core -I flocq/Calc -I flocq/Appli -I flocq/Prop -o lib/Camlcoq.cmo lib/Camlcoq.ml
# File &quot;lib/Camlcoq.ml&quot;, line 60, characters 12-19:
# Error: Unbound value Pos.sub
# Command exited with code 2.
# Makefile:148: recipe for target &#39;ccomp&#39; failed
# make[1]: Leaving directory &#39;/home/bench/.opam/system/build/coq:contrib:compcert.dev&#39;
# Makefile:128: recipe for target &#39;all&#39; failed
### stderr ###
# File &quot;tools/ndfun.ml&quot;, line 12, characters 10-23:
# Warning 3: deprecated: String.create
# Use Bytes.create instead.
# File &quot;tools/ndfun.ml&quot;, line 14, characters 4-52:
# Warning 3: deprecated: String.set
# Use Bytes.set instead.
# make[1]: *** [ccomp] Error 10
# make: *** [all] Error 2
=-=- Error report -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
The following actions failed
  - install coq:contrib:compcert dev
No changes have been performed
&#39;opam install -y -v coq:contrib:compcert.dev&#39; failed.
</pre></dd>
            </dl>
            <h2>Installation size</h2>
            <p>No files were installed.</p>
            <h2>Uninstall</h2>
            <dl class="dl-horizontal">
              <dt>Command</dt>
              <dd><code>true</code></dd>
              <dt>Return code</dt>
              <dd>0</dd>
              <dt>Missing removes</dt>
              <dd>
                none
              </dd>
              <dt>Wrong removes</dt>
              <dd>
                none
              </dd>
            </dl>
          </div>
        </div>
      </div>
      <hr/>
      <div class="footer">
        <p class="text-center">
          <small>Sources are on <a href="https://github.com/coq-bench">GitHub</a>. Â© Guillaume Claret.</small>
        </p>
      </div>
    </div>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <script src="../../../../../bootstrap.min.js"></script>
  </body>
</html>
